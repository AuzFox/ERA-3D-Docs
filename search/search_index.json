{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"Welcome to the ERA-3D Docs! <p>Warning</p> <p>ERA-3D is still in early development and things are subject to change.</p> <p>This documentation is also a work-in-progress.</p> <p>For a guide on building ERA-3D from source, check out the Building page.</p> <p>After building, see the following pages:</p> <ul> <li>Editors: Guides for the built-in asset editors.</li> <li>ERA-C Overview: Overview of the ERA-C scripting language.</li> <li>API Reference: Documentation for all built-in API functions.</li> <li>Memory Map: Breakdown of the virtual memory map.</li> <li>Configuration: Documentation on configuring ERA-3D.</li> </ul>"},{"location":"api-reference/","title":"API Reference","text":"<p>todo</p>"},{"location":"building/","title":"Building","text":"<p>To build ERA-3D, you must first install Nelua. Follow the installation instructions on the Nelua website.</p> <p>Once Nelua is installed, build and install the following C libraries:</p> <ul> <li>raylib v5.0</li> <li>BlipKit</li> <li>zip</li> </ul> <p>Once all dependencies are installed, clone this repository and run the following commands:</p> <pre><code>cd .../ERA-3D/\nnelua --release src/main.nelua -o era-3d\n</code></pre> <p>You should now have the <code>era-3d</code> executable. move <code>era-3d</code> and the <code>assets</code> directory to the desired install location.</p>"},{"location":"configuration/","title":"Configuration","text":""},{"location":"configuration/#introduction","title":"Introduction","text":"<p>ERA-3D stores configuration data, carts, and memory card data in its own folders on the filesystem.</p>"},{"location":"configuration/#data-directories","title":"Data Directories","text":"<p>The ERA-3D data directory can be found in the following places:</p> WindowsLinux <pre><code>C:\\Users\\username\\AppData\\Roaming\\era-3d\n</code></pre> <pre><code>~/.era-3d\n</code></pre> <p>Inside the <code>era-3d</code> directory are the following items:</p> <ul> <li><code>carts</code> directory: default location of saved cart files</li> <li><code>memcards</code> directory: used for storing memcard data files</li> <li><code>config.json</code>: ERA-3D configuration file</li> </ul>"},{"location":"configuration/#config-file-settings","title":"Config File Settings","text":"<p>The following table lists all available configuration settings for <code>config.json</code>.</p> Setting Accepted Values Default Value Description <code>log_level</code> 0-7 7 Raylib event log filter level (see Log Levels table below) <code>vsync</code> <code>true</code>/<code>false</code> <code>true</code> VSYNC enable flag <code>highdpi</code> <code>true</code>/<code>false</code> <code>true</code> HIGHDPI enable flag <code>draw_fps</code> <code>true</code>/<code>false</code> <code>false</code> Debug FPS counter display flag <p>The following table lists the possible values for the <code>log_level</code> setting.</p> <p>Levels are ranked, with each level filtering out all events of lower level value.</p> Log Level Description 0 Log all events 1 Log trace events and higher 2 Log debug events and higher 3 Log info events and higher 4 Log warning events and higher 5 Log error events and higher 6 Log fatal error events 7 Disable event logging"},{"location":"editors/","title":"Editors","text":"<p>todo</p>"},{"location":"era-c-overview/","title":"ERA-C Overview","text":""},{"location":"era-c-overview/#introduction","title":"Introduction","text":"<p>Warning</p> <p>This page assumes you are already familiar with basic programming concepts and data types.</p> <p>ERA-3D games are programmed in a scripting language called ERA-C. ERA-C is similar to C in many ways, but has a few key differences that are worth noting.</p> <p>If you are already familiar with C, see the Differences From C section.</p>"},{"location":"era-c-overview/#comments","title":"Comments","text":"<p>Comments in ERA-C follow the same syntax as C/C++.</p> <pre><code>// single-line comment\nint a = 32; // another comment\n/*\nmulti\nline\ncomment\n*/\n</code></pre> <p>Multi-line comments can be nested.</p> <pre><code>/*\n  this is a comment\n  /*\n    this is a nested comment\n  */\n  this is still a comment\n*/\n</code></pre>"},{"location":"era-c-overview/#variables","title":"Variables","text":"<p>Both local and global variables are declared using the pattern <code>&lt;data type&gt; &lt;name&gt; ;</code>.</p> <p>Variable names must start with a letter and can contain the characters <code>a-z, A-Z, 0-9, _</code></p> <pre><code>int my_int; // an int variable\nfloat my_float; // a float variable\n</code></pre> <p>Local variables (variables declared inside a function or loop scope) can be assigned a value when they are declared.</p> <pre><code>int foo = 42;\n</code></pre> <p>Global variables must be initialized inside of a function.</p> <p>The <code>init()</code> function is a good place for that. (See the Hook Functions section)</p>"},{"location":"era-c-overview/#primitive-types","title":"Primitive Types","text":"<p>Primitive types are data types built into the ERA-C compiler.</p>"},{"location":"era-c-overview/#int","title":"<code>int</code>","text":"<p><code>int</code> is a data type that is capable of storing positive and negative whole numbers.</p> <p>Specifically, they are 32-bit integers. Most operations treat them as signed integers, but some operators treat <code>int</code> values as unsigned.</p> <p>Integer literal values can be given in decimal form, but they can also be represented in hexadecimal and binary form using the <code>0x</code> and <code>0b</code> prefixes.</p> <p>Unlike C, leading zeros do not mean a number is in octal format.</p> <pre><code>int a = 24; // positive value\nint b = -24; // negative value\nint hex = 0xFF; // hexadecimal value (255)\nint binary = 0b10101010; // binary value (170)\n\n// To make large numbers easier to read, underscores can be inserted between digits.\nint big_number = 12_345_678;\n\n// Character literals are also supported, and are interpreted as int values.\nint letter_e = 'E';\n</code></pre> <p><code>int</code>s support various arithmetic operations, as well as bitwise and logical ones.</p> <p><code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, and <code>%</code> are the addition, subtraction, multiplication, division, and modulus operators. They follow the same precedence rules as C.</p> <pre><code>int a = 2 + 2;\nint b = 5 - 3;\nint c = 9 * 100;\nint d = 10 / 2;\nint e = 10 % 5;\n</code></pre> <p>Info</p> <p>Dividing <code>int</code> values does not result in a fractional value, the fractional component is discarded instead.</p> <p><code>5 / 2</code> returns 2, not 2.5.</p> <p>ERA-C also supports bitwise operations for integers.</p> <pre><code>int a = ~0b00001111; // bitwise NOT: a = 0b11110000\nint b = 0b10101010 | 0b01010101; // bitwise OR: b = 0b11111111\nint c = 0b10101111 &amp; 0b00111100; // bitwise AND: c = 0b00101100\nint d = 0b11001100 ^ 0b10101010; // bitwise XOR: d = 0b01100110\nint e = 0b00001111 &lt;&lt; 2; // bitwise left shift: e = 0b00111100\nint f = 0b11110000 &gt;&gt; 4; // bitwise right shift (logical): f = 0b00001111\nint g = 0b10000000 &gt;&gt;&gt; 4; // bitwise right shift (arithmetic): f = 0b11111000\n</code></pre> <p>The logical and comparison operators return an integer value, so their result can be stored in an <code>int</code>.</p> <p>If the comparison is true, a value of 1 is returned. Otherwise, 0 is returned.</p> <pre><code>int a = 1 &lt; 2; // a = 1 (true)\nint b = 1 == 2; // b = 0 (false)\n</code></pre>"},{"location":"era-c-overview/#float","title":"<code>float</code>","text":"<p><code>float</code>s are 32-bit floating point values, meaning they are numbers with a fractional component.</p> <pre><code>float my_float = 2.5;\n</code></pre> <p><code>floats</code> support the <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, and <code>%</code> operators, as well as the comparison operators.</p>"},{"location":"era-c-overview/#vec2","title":"<code>vec2</code>","text":"<p><code>vec2</code> represents a 2D vector with <code>x</code> and <code>y</code> components.</p> <p><code>x</code> and <code>y</code> both have the <code>float</code> data type.</p> <pre><code>vec2 v = vec2(1.0, 2.0); // 2D vector with the value (x=1.0, y=2.0)\n\nv.x = 9.0; // assigning a new x value\nv.y = 0.25; // assigning a new y value\n</code></pre> <p>The following table lists special functions used to construct <code>vec2</code>s with common values:</p> Function <code>vec2</code> Return Value <code>vec2Zero()</code> <code>{0.0, 0.0}</code> (equivalent to <code>vec2()</code> with no arguments) <code>vec2One()</code> <code>{1.0, 1.0}</code> <code>vec2Up()</code> <code>{0.0, -1.0}</code> <code>vec2Down()</code> <code>{0.0, 1.0}</code> <code>vec2Left()</code> <code>{-1.0, 0.0}</code> <code>vec2Right()</code> <code>{1.0, 0.0}</code>"},{"location":"era-c-overview/#vec3","title":"<code>vec3</code>","text":"<p><code>vec3</code> represents a 3D vector with <code>x</code>, <code>y</code>, and <code>z</code> components.</p> <p><code>x</code>, <code>y</code>, and <code>z</code> all have the <code>float</code> data type.</p> <pre><code>vec3 v = vec3(1.0, 2.0, 3.0); // 3D vector with the value (x=1.0, y=2.0, z=3.0)\n\nv.x = 7.5; // assigning a new x value\nv.y = 0.75; // assigning a new y value\nv.z = 4.9; // assigning a new z value\n</code></pre> <p>The following table lists special functions used to construct <code>vec3</code>s with common values:</p> Function <code>vec3</code> Return Value <code>vec3Zero()</code> <code>{0.0, 0.0, 0.0}</code> (equivalent to <code>vec3()</code> with no arguments) <code>vec3One()</code> <code>{1.0, 1.0, 1.0}</code> <code>vec3Up()</code> <code>{0.0, 1.0, 0.0}</code> <code>vec3Down()</code> <code>{0.0, -1.0, 0.0}</code> <code>vec3Left()</code> <code>{-1.0, 0.0, 0.0}</code> <code>vec3Right()</code> <code>{1.0, 0.0, 0.0}</code> <code>vec3Forward()</code> <code>{0.0, 0.0, -1.0}</code> <code>vec3Back()</code> <code>{0.0, 0.0, 1.0}</code> <p>Both <code>vec2</code> and <code>vec3</code> support addition, subtraction, multiplication, and division.</p> <p>Vector types cannot be mixed in vector arithmetic, only vectors of the same dimensions can be added, subtracted, etc.</p> <p>During a arithmetic operation, the individual members of the vector are operated on. For example, when adding two <code>vec2</code> values, the result will be <code>vec2(a.x + b.x, a.y + b.y)</code>. The same pattern applies to all arithmetic operators.</p> <pre><code>vec2 v2 = vec2(1.1, 2.2) + vec2(3.3, 4.4); // v2 = vec2(4.4, 6.6)\nvec3 v3 = vec3(1.1, 2.2, 3.3) + vec3(4.4, 5.5, 6.6); // v3 = vec3(5.5, 7.7, 9.9)\n</code></pre> <p>Vectors can also be multiplied and divided by <code>int</code> and <code>float</code> values. This will return a vector with each member having been multiplied/divided by the <code>int</code>/<code>float</code> value.</p> <pre><code>vec3 a = vec3(1.1, 2.2, 3.3) * 2; // a = vec3(2.2, 4.4, 6.6)\nvec2 b = vec2(5.0, 10.0) / 2.5; // b = vec2(2.0, 4.0)\n</code></pre> <p>Vectors support all comparison operators, and can only be compared with their same type.</p> <p>Comparing vectors compares each member pair, and the comparison is only true if all pairs satisfy the comparison.</p> <pre><code>vec2 a = vec2(10.0, 20.0);\nvec2 b = vec2(1.0, 2.0);\n\nint result = a &lt; b; // result = 1 (true), as a.x &lt; b.x and a.y &lt; b.y\n</code></pre>"},{"location":"era-c-overview/#string","title":"<code>string</code>","text":"<p>The <code>string</code> data type is used to hold text.</p> <p><code>string</code> literals must be enclosed within double-quotes (<code>\"</code>).</p> <pre><code>string text = \"hello world!\";\n</code></pre> <p>To fetch a character from the string, or to change a character, use the following expression: <code>&lt;variable&gt; [ &lt;index&gt; ];</code>.</p> <p>The characters of a string are zero-indexed, meaning that the first character is stored at index 0.</p> <pre><code>string text = \"hello world!\";\nint character = text[0]; // fetch a character\n</code></pre> <p>Internally, <code>string</code> is a struct (see the Structs section) that looks like this:</p> <pre><code>struct string {\n  int length;\n  void* data;\n};\n</code></pre> <p>Strings support the <code>==</code> and <code>!=</code> operators. Two strings are considered equal if the following conditions are met:</p> <ol> <li>both strings are the same length</li> <li>both strings point to the same address or the characters in both strings match</li> </ol>"},{"location":"era-c-overview/#arrays","title":"Arrays","text":"<p>Arrays are essentially blocks of memory used to store a list of elements all of a particular data type. For example, you might have an array containing 10 <code>int</code> values, or an array containing 5 <code>vec2</code> values.</p> <p>Arrays are fixed in size, once they are declared the cannot be resized.</p> <pre><code>int my_array[10]; // declare an array of 10 ints\n</code></pre> <p>Access array elements using the pattern <code>&lt;array variable&gt; [ &lt;index&gt; ]</code>, where <code>&lt;index&gt;</code> is an integer value.</p> <p>Array values are zero-indexed; meaning the first element in the array is stored at index 0, the second at index 1, and so on.</p> <pre><code>int my_array[10];\nint x = my_array[0]; // get the first value stored in the array\nmy_array[1] = 99; // store a new value in the array at index 1\n</code></pre>"},{"location":"era-c-overview/#pointers","title":"Pointers","text":"<p>ERA-C supports pointers, which behave similarly to pointers in C. To declare a pointer to a type, put a <code>*</code> after the data type.</p> <pre><code>int* int_pointer; // pointer to an int\n</code></pre> <p>To obtain the memory address of a variable, use the address-of operator. (<code>&amp;</code>)</p> <pre><code>int x = 42; // normal int variable\nint* ptr = &amp;x; // ptr now contains the memory address of x \n</code></pre> <p>The unary dereference operator (<code>*</code>) can be used to fetch the value pointed to by a pointer.</p> <pre><code>int x = 42;\nint* ptr = &amp;x;\nint y = *ptr; // y now contains the same value as x\n</code></pre> <p>Like arrays, pointers can be used to access multiple contiguous values stored next to each other in memory.</p> <pre><code>int* p = 0; // in this example, p points to memory address 0, which corresponds to general-purpose memory.\nint first = p[0]; // get the first value stored at the address p points to\np[1] = 100; // store a new value at the address p points to plus an offset of 1 int. (which would be the address 4. 1 int = 4 bytes)\n</code></pre> <p>A pointer with the type <code>void*</code> is a special type of pointer that can point to any data type. Pointers of this type are called \"void pointers\".</p> <p>Void pointers cannot be dereferenced, they are only used as a container for arbitrary memory addresses.</p> <p>Any pointer type and be assigned the value of a void pointer, and vice versa.</p> <pre><code>int i = 100;\nfloat f = 32.2;\nvoid* p = &amp;i; // p points to i\nint x = *p; // ERROR: cannot dereference void pointers!\np = &amp;f; // p now points to f\n</code></pre> <p>Pointers can be assigned arbitrary integer values, and thus arbitrary memory addresses.</p> <p>In C, this is dangerous and discouraged most of the time, but in ERA-C it is needed to access specific parts of memory.</p> <pre><code>int* p = 0x00800000; // p now points to address 0x00800000, which is the beginning of the system's texture memory\n</code></pre> <p>Warning</p> <p>Pointers in ERA-C must be aligned when dereferencing them, meaning the address they contain must be a multiple of the size of the type they point to (or address 0). If a pointer is misaligned when it is dereferenced, en error will be raised and the program will halt.</p> <p>Pointers can be added to or subtracted from, changing the address they point to. This is referred to as \"pointer arithmetic\".</p> <p>Adding a value of 1 to a pointer will increase its address by the size of the data type it points to.</p> <p>For example, adding 1 to a <code>int*</code> will increase its address by 4, since <code>int</code>s are 4 bytes in size.</p> <p>Info</p> <p>Void pointers do not support pointer arithmetic.</p> <pre><code>int* p = 0;\np = p + 1; // p now points to the next int in memory\n</code></pre> <p>The <code>sizeof()</code> operator will return the size of a given type in bytes.</p> <pre><code>int size = sizeof(int); // size = 4\n</code></pre> <p><code>null</code> is a special constant that represents an invalid memory address. Unlike C's <code>NULL</code>, it is not equal to the integer value 0.</p> <p>Assign a pointer to <code>null</code> to signify that it does not currently point to a valid address.</p> <pre><code>void* p = null;\n</code></pre>"},{"location":"era-c-overview/#structs","title":"Structs","text":"<p>Structs are compound data types that are made up of other smaller types. They are useful for representing complex objects with many attributes.</p> <pre><code>struct MyStruct {\n  int a;\n  float b;\n  int c;\n};\n</code></pre> <p>In the above example, the struct <code>MyStruct</code> is declared, and contains an <code>int</code> and <code>float</code> members.</p> <p>Info</p> <p>Structs must be declared outside of any function, and before they are used as a variable type.</p> <p>To create a struct instance variable, use the struct name as the variable type.</p> <pre><code>MyStruct instance;\n</code></pre> <p>Struct instances can be created using the pattern <code>&lt;struct name&gt; ( &lt;member values...&gt; )</code></p> <pre><code>Mystruct instance = Mystruct(1, 2.5, 3); // create a MyStruct instance with the value (a=1, b=2.5, c=3)\n</code></pre> <p>C-style struct initializers are also allowed.</p> <p>These use the pattern <code>( &lt;struct name&gt; ) { &lt;member values...&gt; }</code></p> <pre><code>Mystruct instance = (Mystruct){1, 2.5, 3}; // create a MyStruct instance with the value (a=1, b=2.5, c=3)\n</code></pre> <p>If a struct initializer's member value list is left empty, all struct members will be initialized to zero.</p> <pre><code>MyStruct instance = MyStruct(); // instance = (0, 0.0, 0)\nvec3 v = vec3(); // v = (0.0, 0.0, 0.0)\n</code></pre> <p>To access struct members, use the dot operator. (<code>.</code>)</p> <pre><code>Mystruct instance = MyStruct(1, 2.5, 3);\nint x = instance.a; // x now contains 1\ninstance.b = 10.1; // set the b member of instance to a new value\n</code></pre> <p>When accessing a struct using a pointer, the arrow operator (<code>-&gt;</code>) must be used instead of the dot operator.</p> <pre><code>Mystruct instance = MyStruct(1, 2.5, 3);\nMyInstance* p = &amp;instance; // p points to instance\np -&gt; a = 22; // access the a member of instance using the pointer p\n</code></pre>"},{"location":"era-c-overview/#function-pointers","title":"Function Pointers","text":"<p>Function pointers are special pointers that point to code, rather than data.</p> <p>To declare a function pointer, use the pattern <code>&lt;return type&gt; ( &lt;argument types...&gt; ) &lt;variable name&gt; ;</code></p> <pre><code>void(int, float) func_ptr; // func_ptr points to a function that accepts an `int` and `float` argument and does not return a value.\n</code></pre> <p>Assign a function pointer by using the name of the function to point to.</p> <pre><code>void my_function(int a, float b) {\n  // ... function code here ...\n}\n\nvoid(int, float) func_ptr = my_function;\n</code></pre> <p>Function pointers do not support pointer arithmetic, and can only be cast to <code>void*</code>.</p> <p>Function pointers can be assigned <code>null</code>.</p>"},{"location":"era-c-overview/#type-casting","title":"Type Casting","text":"<p>Type casting in ERA-C works much like C. To cast an expression to another type, use the pattern <code>( &lt;type&gt; ) &lt;expression&gt;</code>.</p> <pre><code>float f = 2.5;\nint i = (int)f; // cast the float value of f to an int\n</code></pre> <p><code>float</code> to <code>int</code> casting discards the fractional component of the <code>float</code>. (The value is truncated)</p> <p>In the above example, <code>i</code> would have the value 2 after the cast.</p> <p>The following table lists all accepted casts:</p> Original Type Target Type Result <code>int</code> <code>float</code> <code>float</code> equal to the original integer value. <code>int</code> Non-function pointer Pointer with address equal to the original integer value. <code>float</code> <code>int</code> <code>int</code> containing the truncated integer value of the <code>float</code>. Non-function pointer <code>int</code> <code>int</code> containing the address of the original pointer value. Function pointer <code>void*</code> <code>void*</code> containing the address of the original function pointer value. <code>void*</code> Function pointer Function pointer containing the address of the original void pointer value."},{"location":"era-c-overview/#enums","title":"Enums","text":"<p>Enums are lists of compile-time constants used to represent numerical values.</p> <pre><code>// declaring an enum\nenum {\n  VALUE_A = 0, // enum entries can be assigned direct values\n  VALUE_B, // when no value is given, an entry is assigned a value that is 1 higher than the previous entry\n  VALUE_C\n};\n\n// using the enum entries\nint x = VALUE_C; // x = 2\n</code></pre> <p>Info</p> <p>Enums must be declared outside of any function, and before their members are used in an expression.</p>"},{"location":"era-c-overview/#operators","title":"Operators","text":"<p>ERA-C has the following operators:</p> Operator Description <code>+</code> Addition <code>-</code> Subtraction <code>*</code> Multiplication <code>/</code> Division <code>%</code> Modulus <code>!</code> Logical Not (Unary) <code>&amp;&amp;</code> Logical And <code>||</code> Logical Or <code>==</code> Equal-to Comparision <code>!=</code> Not-Equal-to Comparision <code>&lt;</code> Less-Than Comparision <code>&gt;</code> Greater-Than Comparision <code>&lt;=</code> Less-Than-or-Equal-to Comparision <code>&gt;=</code> Greater-Than-or-Equal-to Comparision <code>~</code> Bitwise NOT (Unary) <code>&amp;</code> Bitwise AND <code>|</code> Bitwise OR <code>^</code> Bitwise XOR <code>&lt;&lt;</code> Bitwise Left Shift <code>&gt;&gt;</code> Bitwise Logical Right Shift <code>&gt;&gt;&gt;</code> Bitwise Arithmetic Right Shift <code>.</code> Struct Member Access <code>-&gt;</code> Struct Member Access (Pointer) <code>sizeof()</code> Type Size (in bytes)"},{"location":"era-c-overview/#control-flow","title":"Control Flow","text":"<p><code>if</code> statements work just like in C.</p> <pre><code>int x = 1;\n\nif (x == 1) {\n  // do something...\n}\nelse if (x == 2) {\n  // do something else...\n}\nelse {\n  // no previous conditions were true\n}\n</code></pre> <p><code>int</code> values can be used as conditions. A value of 0 is <code>false</code>, all non-zero values are <code>true</code>.</p> <p>Pointers and function pointers can be used as the <code>if</code> statement condition to check if they point to valid addresses.</p> <pre><code>void* p = null;\n\nif (p) {\n  // p points to a valid address\n}\nelse {\n  // p is not valid\n}\n</code></pre> <p>Info</p> <p>The expression <code>my_pointer == null</code> will only be true if <code>my_pointer</code> contains exactly the value <code>null</code>.</p>"},{"location":"era-c-overview/#loops","title":"Loops","text":"<p>ERA-C supports <code>for</code> and <code>while</code> loops with the same syntax as C.</p> <p><pre><code>for (int i = 0; i &lt; 10; i = i + 1) {\n  // do something...\n}\n</code></pre> <pre><code>while (a == b) {\n  // do something...\n}\n</code></pre></p> <p>The <code>break</code> keyword will end the current loop immediately.</p> <pre><code>for (int i = 0; i &lt; 10; i = i + 1) {\n  if (i == 5) {\n    break; // exit the loop body\n  }\n\n  // do something with i...\n}\n</code></pre> <p>The <code>continue</code> keyword will skip to the next loop iteration.</p> <pre><code>for (int i = 0; i &lt; 10; i = i + 1) {\n  if (i == 5) {\n    continue; // the rest of the loop body is skipped, and the loop starts again after incrementing i\n  }\n\n  // do something with i...\n}\n</code></pre>"},{"location":"era-c-overview/#functions","title":"Functions","text":"<p>Functions in ERA-C follow mostly the same syntax as C.</p> <pre><code>// declaring a function\nvoid my_function(int a, float b) {\n   // do something...\n}\n\n// calling the function\nmy_function(1, 2.0);\n</code></pre> <p>The <code>return</code> keyword returns a value from a function.</p> <pre><code>int add(int a, int b) {\n   return a + b;\n}\n</code></pre> <p>Info</p> <p>Unlike C, a function that lists no arguments is a function that accepts no arguments.</p> <p>The C style <code>void my_function(void)</code> will not compile in ERA-C.</p>"},{"location":"era-c-overview/#vararg-functions","title":"Vararg Functions","text":"<p>Functions that accept a variable number of arguments are called \"vararg\" or \"variadic\" functions.</p> <p>The special vararg type (<code>...</code>) is used to indicate that a function is variadic.</p> <p>The vararg type must come after all other non-optional arguments.</p> <pre><code>// declaring a variadic function\nvoid my_function(int a, float b, ...) {\n  // do something...\n}\n\n// calling the function\nmy_function(1, 2.0, 3, 4, 5);\n</code></pre> <p>To access vararg arguments, use the <code>vargc()</code> and <code>vargv()</code> API functions.</p> <p><code>vargc()</code> takes no arguments and returns the remaining number of bytes available in the varargs list.</p> <pre><code>if (vargc() &gt;= 4) {\n  // there are at least 4 bytes of vararg data left.\n}\n</code></pre> <p><code>vargv()</code> returns a <code>void*</code> pointing to the current vararg argument, and accepts a size in bytes as an argument.</p> <p>The size given to <code>vargv()</code> is the offset to give the vararg pointer in order to move past the current argument.</p> <p>It is recommended to use <code>sizeof()</code> to get argument size.</p> <pre><code>int sum(...) {\n  int result = 0;\n  while (vargc() &gt;= sizeof(int)) {\n    int* arg_pointer = (int*) vargv(sizeof(int));\n    result = result + *arg_pointer;\n  }\n  return result;\n}\n\n// calling sum()\nint value = sum(1, 2, 3, 4, 5); // value = 15\n</code></pre> <p>The above snippet is an example of a simple sum function that adds a variable number of integers.</p>"},{"location":"era-c-overview/#hook-functions","title":"Hook Functions","text":"<p>ERA-3D recognizes special \"hook\" functions declared in a ERA-C program and will call them at certain times.</p> <p>At least one hook function must be declared in order for a cart to run.</p>"},{"location":"era-c-overview/#init","title":"<code>init</code>","text":"<p>if a function is declared with the signature <code>void init()</code>, it will be called once when a cart is ran.</p> <p>Use this function to initialize game state.</p> <pre><code>void init() {\n  // initialize state here...\n}\n</code></pre>"},{"location":"era-c-overview/#update","title":"<code>update</code>","text":"<p>if a function is declared with the signature <code>void update(float delta_time)</code>, it will be called once every frame.</p> <p>Use this function to update game state. (check inputs, move objects, etc.)</p> <p><code>delta_time</code> will be passed to the function automatically, and will contain the amount of time (in seconds) since the last frame.</p> <pre><code>void update(float delta_time) {\n  // update state here...\n}\n</code></pre> <p>Info</p> <p>The <code>delta_time</code> argument for <code>update()</code> can be given any other name, but it must be a <code>float</code>.</p>"},{"location":"era-c-overview/#draw","title":"<code>draw</code>","text":"<p>if a function is declared with the signature <code>void draw()</code>, it will be called once every frame after the call to <code>update()</code>.</p> <p>Use this function to configure rendering settings and to render graphics to the screen.</p> <pre><code>void draw() {\n  // render graphics here...\n}\n</code></pre>"},{"location":"era-c-overview/#built-in-constants","title":"Built-in Constants","text":"<p>The ERA-C compiler has several built-in constants for use with various functions. The following table lists their names and values:</p> Name Value true <code>1</code> false <code>0</code> null <code>0xFFFFFFFF</code> SCREEN_WIDTH <code>480</code> SCREEN_HEIGHT <code>360</code> FONT_WIDTH <code>6</code> FONT_HEIGHT <code>9</code> MESH_LINES <code>0</code> MESH_TRIANGLES <code>1</code> MESH_QUADS <code>2</code> MAT_PROJECTION <code>0</code> MAT_MODELVIEW <code>1</code> CLEAR_NONE <code>0</code> CLEAR_COLOR <code>0b100</code> CLEAR_DEPTH <code>0b010</code> CLEAR_STENCIL <code>0b001</code> CLEAR_ALL <code>0b111</code> COLOR_NONE <code>0</code> COLOR_R <code>0b1000</code> COLOR_G <code>0b0100</code> COLOR_B <code>0b0010</code> COLOR_A <code>0b0001</code> COLOR_ALL <code>0b1111</code> TEXTURE_WRAP <code>0</code> TEXTURE_CLAMP <code>1</code> TEXTURE_NONE <code>2</code> CULL_BACK <code>0</code> CULL_FRONT <code>1</code> CULL_NONE <code>2</code> BLEND_ALPHA <code>0</code> BLEND_ADD <code>1</code> BLEND_MULTIPLY <code>2</code> BLEND_ADD_ALT <code>3</code> BLEND_SUBTRACT <code>4</code> BLEND_PREMULTIPLY <code>5</code> BLEND_CUSTOM <code>6</code> BLEND_CUSTOM_EX <code>7</code> CAM_PERSPECTIVE <code>0</code> CAM_ORTHOGRAPHIC <code>1</code> LIGHT_POINT <code>0</code> LIGHT_DIRECTIONAL <code>1</code> FACE_FRONT <code>0</code> FACE_BACK <code>1</code> FACE_BOTH <code>2</code> FUNC_LESS <code>0</code> FUNC_LEQUAL <code>1</code> FUNC_GREATER <code>2</code> FUNC_GEQUAL <code>3</code> FUNC_EQUAL <code>4</code> FUNC_NOTEQUAL <code>5</code> FUNC_ALWAYS <code>6</code> FUNC_NEVER <code>7</code> FACTOR_ZERO <code>0</code> FACTOR_ONE <code>1</code> FACTOR_SRC_RGB <code>2</code> FACTOR_ONE_MINUS_SRC_RGB <code>3</code> FACTOR_DST_RGB <code>4</code> FACTOR_ONE_MINUS_DST_RGB <code>5</code> FACTOR_SRC_ALPHA <code>6</code> FACTOR_ONE_MINUS_SRC_ALPHA <code>7</code> FACTOR_DST_ALPHA <code>8</code> FACTOR_ONE_MINUS_DST_ALPHA <code>9</code> FACTOR_CONSTANT_RGB <code>10</code> FACTOR_ONE_MINUS_CONSTANT_RGB <code>11</code> FACTOR_CONSTANT_ALPHA <code>12</code> FACTOR_ONE_MINUS_CONSTANT_ALPHA <code>13</code> FACTOR_SRC_ALPHA_SATURATE <code>14</code> EQ_ADD <code>0</code> EQ_SUBTRACT <code>1</code> EQ_SUBTRACT_REVERSE <code>2</code> EQ_MIN <code>3</code> EQ_MAX <code>4</code> STENCIL_KEEP <code>0</code> STENCIL_REPLACE <code>1</code> STENCIL_INC <code>2</code> STENCIL_INC_WRAP <code>3</code> STENCIL_DEC <code>4</code> STENCIL_DEC_WRAP <code>5</code> STENCIL_ZERO <code>6</code> STENCIL_INVERT <code>7</code> BTN_UP <code>0</code> BTN_DOWN <code>1</code> BTN_LEFT <code>2</code> BTN_RIGHT <code>3</code> BTN_TRIANGLE <code>4</code> BTN_CROSS <code>5</code> BTN_SQUARE <code>6</code> BTN_CIRCLE <code>7</code> BTN_L1 <code>8</code> BTN_L2 <code>9</code> BTN_R1 <code>10</code> BTN_R2 <code>11</code> BTN_SELECT <code>12</code> BTN_START <code>13</code>"},{"location":"era-c-overview/#built-in-structs","title":"Built-in Structs","text":"<p>ERA-C has multiple built-in struct types for representing various objects. Unlike the vector and <code>string</code> types, which behave like structs in certain situations, these built-in structs do not have any custom functionality built into the compiler.</p>"},{"location":"era-c-overview/#matrix","title":"<code>matrix</code>","text":"<p>The <code>matrix</code> struct is a 4x4 matrix used for storing transformations like translation, rotation, and scale.</p> <p>TODO: explain member ordering</p> <pre><code>struct matrix {\n  float m0; float m4; float m8; float m12;  // first row\n  float m1; float m5; float m9; float m13;  // second row\n  float m2; float m6; float m10; float m14; // third row\n  float m3; float m7; float m11; float m15; // fourth row\n};\n</code></pre>"},{"location":"era-c-overview/#vertex","title":"<code>vertex</code>","text":"<p>The <code>vertex</code> struct contains 3D vertex data according to the order that vertex data is stored in OBJMEM and OBJBANKs.</p> <p>Thus, OBJMEM and OBJBANKs can be treated as arrays of <code>vertex</code> structs.</p> <pre><code>struct vertex {\n  vec3 position;\n  vec3 normal;\n  vec2 uv;\n  int color;\n};\n</code></pre>"},{"location":"era-c-overview/#cam2d","title":"<code>cam2d</code>","text":"<p>In SYSMEM, there are 4 memory-mapped 2D cameras that can be used for configuring the view.</p> <p>To get a pointer to a 2D camera, use the <code>getCam2D()</code> function.</p> <pre><code>cam2d* cam = getCam2D(0); // get a pointer to 2D camera 0\n</code></pre> <p>To configure the view to a built-in 2D camera, use the <code>camera2D()</code> function.</p> <pre><code>camera2D(0); // use 2D camera 0\n</code></pre> <p>Info</p> <p>When <code>camera2D()</code> is called, depth testing is automatically disabled.</p> <p>The <code>cam2d</code> struct has the following definition:</p> <pre><code>struct cam2d {\n  vec2 offset;\n  vec2 target;\n  float rotation;\n  float zoom;\n};\n</code></pre>"},{"location":"era-c-overview/#cam3d","title":"<code>cam3d</code>","text":"<p>In SYSMEM, there are 4 memory-mapped 3D cameras that can be used for configuring the view.</p> <p>To get a pointer to a 3D camera, use the <code>getCam3D()</code> function.</p> <pre><code>cam3d* cam = getCam3D(0); // get a pointer to 3D camera 0\n</code></pre> <p>To configure the view to a built-in 3D camera, use the <code>camera3D()</code> function.</p> <pre><code>camera3D(0); // use 3D camera 0\n</code></pre> <p>Info</p> <p>When <code>camera3D()</code> is called, depth testing is automatically enabled.</p> <p>The <code>cam3d</code> struct has the following definition:</p> <pre><code>struct cam3d {\n  vec3 position;\n  vec3 target;\n  vec3 up;\n  float fov;\n  int projection;\n};\n</code></pre>"},{"location":"era-c-overview/#light","title":"<code>light</code>","text":"<p>In SYSMEM, there are 8 memory-mapped lights that are used when lighting is enabled.</p> <p>To get a pointer to a light, use the <code>getLight()</code> function.</p> <pre><code>light* light0 = getLight(0); // get a pointer to light 0\n</code></pre> <p>The <code>light</code> struct has the following definition:</p> <pre><code>struct light {\n  int enabled;\n  int type;\n  float radius;\n  int color;\n  vec3 position;\n  vec3 direction;\n};\n</code></pre>"},{"location":"era-c-overview/#collision-objects","title":"Collision Objects","text":"<p>Warning</p> <p>The physics system is very experimental and subject to change.</p> <p>Currently, collision detection is only implemented for <code>colaabb</code> vs <code>colaabb</code>.</p> <p>ERA-3D has built-in API functions for 3D collision detection. These API functions accept pointers to collision object structs to know what objects to test.</p> <p>Each collision object struct contains a <code>type</code> integer member that must be set to the correct ID value in order for the collision functions to properly identify them.</p> <p>The following table lists all collision object IDs:</p> ID Collision Object Struct <code>0</code> <code>colpoint</code> <code>1</code> <code>colaabb</code> <code>2</code> <code>colsphere</code> <code>3</code> <code>colcylinder</code> <code>4</code> <code>coltriangle</code> <p>To check for collisions using these structs, use the <code>checkCollision()</code> API function.</p> <pre><code>colaabb box1 = colaabb(1, vec3(), 1.0, 0.5, 1.0);\ncolaabb box2 = colaabb(1, vec3(), 0.5, 1.0, 0.5);\n\nif (checkCollision(&amp;box1, &amp;box2)) {\n  // box1 and box2 are colliding!\n  // handle collision here...\n}\n</code></pre>"},{"location":"era-c-overview/#colpoint","title":"<code>colpoint</code>","text":"<p>A <code>colpoint</code> represents a single point in 3D space.</p> <pre><code>struct colpoint {\n  int type;\n  vec3 position;\n};\n</code></pre>"},{"location":"era-c-overview/#colaabb","title":"<code>colaabb</code>","text":"<p>A <code>colaabb</code> represents an Axis Aligned Bounding Box, a 3D box that cannot be rotated.</p> <pre><code>struct colaabb {\n  int type;\n  vec3 position;\n  float width;\n  float height;\n  float depth;\n};\n</code></pre>"},{"location":"era-c-overview/#colsphere","title":"<code>colsphere</code>","text":"<p>A <code>colsphere</code> represents a 3D sphere.</p> <pre><code>struct colsphere {\n  int type;\n  vec3 position;\n  float radius;\n};\n</code></pre>"},{"location":"era-c-overview/#colcylinder","title":"<code>colcylinder</code>","text":"<p>A <code>colcylinder</code> represents a 3D cylinder.</p> <pre><code>struct colcylinder {\n  int type;\n  vec3 position;\n  float height;\n  float radius;\n};\n</code></pre>"},{"location":"era-c-overview/#coltriangle","title":"<code>coltriangle</code>","text":"<p>A <code>coltriangle</code> represents a 3D triangle.</p> <pre><code>struct coltriangle {\n  int type;\n  vec3 point1;\n  vec3 point2;\n  vec3 point3;\n};\n</code></pre>"},{"location":"era-c-overview/#differences-from-c","title":"Differences From C","text":"<p>The following table lists the main differences between C and ERA-C semantics.</p> C ERA-C Multi-line comments cannot be nested Multi-line comments can be nested Multiple integer and floating-point types of various sizes Only <code>int</code> and <code>float</code>, both 32-bit (4 bytes) Leading zeros indicate octal format Leading zeros do not indicate octal format, and are ignored Pointer &lt;-&gt; Integer conversion is not generally recommended Pointer &lt;-&gt; <code>int</code> is 100% legal <code>NULL</code> <code>null</code> <code>NULL</code> == 0 <code>null</code> != 0 <code>void foo()</code> accepts any number of arguments <code>void foo()</code> does not accept any arguments <code>void foo(void)</code> does not accept any arguments <code>void foo(void)</code> is a compile error <code>main()</code> is the program starting point Hook functions <code>init()</code>, <code>update()</code>, and <code>draw()</code> are called periodically"},{"location":"memory-map/","title":"Memory Map","text":"<p>This page details ERA-3D's memory map, as of version <code>0.0.0</code>.</p> <p>Many things in ERA-3D are mapped into virtual memory, and can be modified using pointers to certain addresses.</p> <p>The following table lists all memory regions in the memory map, and each region is explained below.</p> <p>Info</p> <p>All memory in ERA-3D is arranged in big-endian format.</p>"},{"location":"memory-map/#memory-regions-table","title":"Memory Regions Table","text":"Memory Region Size Address Range Description System Memory <code>HEAP</code> <code>8MiB</code> <code>0x00000000-0x007FFFFF</code> General purpose RAM <code>TEXMEM</code> <code>4MiB</code> <code>0x00800000-0x00BFFFFF</code> Texture data <code>OBJMEM</code> <code>3MiB + 384KiB</code> <code>0x00C00000-0x00F5FFFF</code> Mesh data <code>AOBMEM</code> <code>8KiB</code> <code>0x00F60000-0x00F61FFF</code> Audio output buffer <code>SYSMEM</code> <code>632KiB</code> <code>0x00F62000-0x00FFFFFF</code> System state memory <code>WAVMEM</code> <code>7MiB</code> <code>0x01000000-0x016FFFFF</code> Audio wave data <code>SEQMEM</code> <code>256KiB</code> <code>0x01700000-0x0173FFFF</code> Audio sequencer data <code>GLOBALS</code> <code>256KiB</code> <code>0x01740000-0x0177FFFF</code> VM global variables <code>LOCALS</code> <code>256KiB</code> <code>0x01780000-0x017BFFFF</code> VM local variables <code>ARGS</code> <code>256KiB</code> <code>0x017C0000-0x017FFFFF</code> VM function arguments Cartridge ROM <code>TEXBANK[0-3]</code> <code>16MiB</code> <code>0x01800000-0x027FFFFF</code> 4x texture sheets <code>OBJBANK[0-3]</code> <code>13MiB + 512KiB</code> <code>0x02800000-0x0357FFFF</code> 4x mesh data buffers <code>OMPBANK[0-3]</code> <code>1MiB + 256KiB</code> <code>0x03580000-0x036BFFFF</code> 4x maps for OBJBANK[0-3] <code>WMPBANK[0-1]</code> <code>1MiB + 256KiB</code> <code>0x036C0000-0x037FFFFF</code> 2x maps for WAVBANK[0-1] <code>WAVBANK[0-1]</code> <code>14MiB</code> <code>0x03800000-0x045FFFFF</code> 2x wave data buffers <code>SEQBANK[0-7]</code> <code>2MiB</code> <code>0x04600000-0x047FFFFF</code> 8x audio sequencer data buffers <code>ROM</code> <code>16MiB</code> <code>0x04800000-0x057FFFFF</code> String data + user ROM Memory Card <code>MEMCARD</code> <code>4KiB</code> <code>0x05800000-0x05800FFF</code> Persistent save data"},{"location":"memory-map/#system-memory","title":"System Memory","text":"<p>TODO</p>"},{"location":"memory-map/#heap","title":"<code>HEAP</code>","text":"<p>todo</p>"},{"location":"memory-map/#texmem","title":"<code>TEXMEM</code>","text":"<p>todo</p>"},{"location":"memory-map/#objmem","title":"<code>OBJMEM</code>","text":"<p>todo</p>"},{"location":"memory-map/#aobmem","title":"<code>AOBMEM</code>","text":"<p>todo</p>"},{"location":"memory-map/#sysmem","title":"<code>SYSMEM</code>","text":"<p>todo</p>"},{"location":"memory-map/#wavmem","title":"<code>WAVMEM</code>","text":"<p>todo</p>"},{"location":"memory-map/#seqmem","title":"<code>SEQMEM</code>","text":"<p>todo</p>"},{"location":"memory-map/#globals","title":"<code>GLOBALS</code>","text":"<p>todo</p>"},{"location":"memory-map/#locals","title":"<code>LOCALS</code>","text":"<p>todo</p>"},{"location":"memory-map/#args","title":"<code>ARGS</code>","text":"<p>todo</p>"},{"location":"memory-map/#cartridge-rom","title":"Cartridge ROM","text":"<p>todo</p>"},{"location":"memory-map/#texbank0-3","title":"<code>TEXBANK[0-3]</code>","text":"<p>todo</p>"},{"location":"memory-map/#objbank0-3","title":"<code>OBJBANK[0-3]</code>","text":"<p>todo</p>"},{"location":"memory-map/#ompbank0-3","title":"<code>OMPBANK[0-3]</code>","text":"<p>todo</p>"},{"location":"memory-map/#wmpbank0-1","title":"<code>WMPBANK[0-1]</code>","text":"<p>todo</p>"},{"location":"memory-map/#wavbank0-1","title":"<code>WAVBANK[0-1]</code>","text":"<p>todo</p>"},{"location":"memory-map/#seqbank0-7","title":"<code>SEQBANK[0-7]</code>","text":"<p>todo</p>"},{"location":"memory-map/#rom","title":"<code>ROM</code>","text":"<p>todo</p>"},{"location":"memory-map/#memory-card","title":"Memory Card","text":"<p>todo</p>"}]}