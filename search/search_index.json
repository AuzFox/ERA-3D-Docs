{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"Welcome to the ERA-3D Docs! <p>Warning</p> <p>ERA-3D is still in early development and things are subject to change.</p> <p>This documentation is also a work-in-progress.</p> <p>For a guide on building ERA-3D from source, check out the Building page.</p> <p>After building, see the following pages:</p> <ul> <li>User Guide: Guide for using the program.</li> <li>Demos: Download page containing demo programs demonstrating various aspects of ERA-3D.</li> <li>ERA-C Overview: Overview of the ERA-C scripting language.</li> <li>API Reference: Documentation for all built-in API functions.</li> <li>Memory Map: Breakdown of the virtual memory map.</li> <li>Configuration: Documentation on configuring ERA-3D.</li> </ul>"},{"location":"api-reference/","title":"API Reference","text":""},{"location":"api-reference/#introduction","title":"Introduction","text":"<p>This page contains documentation for all of ERA-3D's API Functions.</p> <p>Info</p> <p>A brief description of each function can be accessed using the ERA-3D console.</p> <p>Access the console by pressing Ctrl+Enter.</p> <p>The console command <code>api</code> will open a list of API functions, use the arrow keys to navigate and press Enter to view a function's description.</p> <p>To quickly get the description of a specific function, run the console command <code>help &lt;function&gt;</code>.</p>"},{"location":"api-reference/#function-catagories","title":"Function Catagories","text":"<p>API functions are organized into several catagories, click a catagory below or in the sidebar to jump to the related functions.</p> <p>You can also use the search bar in the site header to search for a particular function.</p> <ul> <li>Math</li> <li>Vectors</li> <li>Matrices</li> <li>Input</li> <li>Graphics</li> <li>Audio</li> <li>Physics</li> <li>Memory</li> <li>Misc</li> </ul>"},{"location":"api-reference/#math","title":"Math","text":""},{"location":"api-reference/#ceil","title":"<code>ceil</code>","text":"<p>Signature:</p> <p><code>float ceil(float x)</code></p> <p>Arguments:</p> <ul> <li><code>float x</code>: Input value</li> </ul> <p>Description:</p> <p>Returns x rounded upward to the nearest whole number. This function always rounds toward positive infinity.</p>"},{"location":"api-reference/#cos","title":"<code>cos</code>","text":"<p>Signature:</p> <p><code>float cos(float x)</code></p> <p>Arguments:</p> <ul> <li><code>float x</code>: Input value</li> </ul> <p>Description:</p> <p>Returns the cosine of x. Return value ranges from <code>-1.0</code> to <code>1.0</code>.</p>"},{"location":"api-reference/#deg","title":"<code>deg</code>","text":"<p>Signature:</p> <p><code>float deg(float angle)</code></p> <p>Arguments:</p> <ul> <li><code>float angle</code>: Input angle (in radians)</li> </ul> <p>Description:</p> <p>Returns angle in degrees.</p>"},{"location":"api-reference/#floor","title":"<code>floor</code>","text":"<p>Signature:</p> <p><code>float floor(float x)</code></p> <p>Arguments:</p> <ul> <li><code>float x</code>: Input value</li> </ul> <p>Description:</p> <p>Returns x rounded downward to the nearest whole number. This function always rounds toward negative infinity.</p>"},{"location":"api-reference/#fract","title":"<code>fract</code>","text":"<p>Signature:</p> <p><code>float fract(float x)</code></p> <p>Arguments:</p> <ul> <li><code>float x</code>: The value to get the fractional component of</li> </ul> <p>Description:</p> <p>Returns the fractional component of x.</p>"},{"location":"api-reference/#maxf","title":"<code>maxf</code>","text":"<p>Signature:</p> <p><code>float maxf(float a, float b)</code></p> <p>Arguments:</p> <ul> <li><code>float a</code>: The first value to check</li> <li><code>float b</code>: The second value to check</li> </ul> <p>Description:</p> <p>Returns the higher of the two given floats.</p>"},{"location":"api-reference/#maxi","title":"<code>maxi</code>","text":"<p>Signature:</p> <p><code>int maxi(int a, int b)</code></p> <p>Arguments:</p> <ul> <li><code>int a</code>: The first value to check</li> <li><code>int b</code>: The second value to check</li> </ul> <p>Description:</p> <p>Returns the higher of the two given integers.</p>"},{"location":"api-reference/#midf","title":"<code>midf</code>","text":"<p>Signature:</p> <p><code>float midf(float a, float b, float c)</code></p> <p>Arguments:</p> <ul> <li><code>float a</code>: The first value to check</li> <li><code>float b</code>: The second value to check</li> <li><code>float c</code>: The third value to check</li> </ul> <p>Description:</p> <p>Returns the middle of the three given floats.</p>"},{"location":"api-reference/#midi","title":"<code>midi</code>","text":"<p>Signature:</p> <p><code>int midi(int a, int b, int c)</code></p> <p>Arguments:</p> <ul> <li><code>int a</code>: The first value to check</li> <li><code>int b</code>: The second value to check</li> <li><code>int c</code>: The third value to check</li> </ul> <p>Description:</p> <p>Returns the middle of the three given integers.</p>"},{"location":"api-reference/#minf","title":"<code>minf</code>","text":"<p>Signature:</p> <p><code>float minf(float a, float b)</code></p> <p>Arguments:</p> <ul> <li><code>float a</code>: The first value to check</li> <li><code>float b</code>: The second value to check</li> </ul> <p>Description:</p> <p>Returns the lower of the two given floats.</p>"},{"location":"api-reference/#mini","title":"<code>mini</code>","text":"<p>Signature:</p> <p><code>int mini(int a, int b)</code></p> <p>Arguments:</p> <ul> <li><code>int a</code>: the first value to check</li> <li><code>int b</code>: the second value to check</li> </ul> <p>Description:</p> <p>Returns the lower of the two given integers.</p>"},{"location":"api-reference/#powf","title":"<code>powf</code>","text":"<p>Signature:</p> <p><code>float powf(float x, float exp)</code></p> <p>Arguments:</p> <ul> <li><code>float x</code>: The base value</li> <li><code>float exp</code>: The exponent value</li> </ul> <p>Description:</p> <p>Returns x raised to the power of exp.</p>"},{"location":"api-reference/#rad","title":"<code>rad</code>","text":"<p>Signature:</p> <p><code>float rad(float angle)</code></p> <p>Arguments:</p> <ul> <li><code>float angle</code>: Input angle (in degrees)</li> </ul> <p>Description:</p> <p>Returns angle in radians.</p>"},{"location":"api-reference/#randf","title":"<code>randf</code>","text":"<p>Signature:</p> <p><code>float randf(float min, float max)</code></p> <p>Arguments:</p> <ul> <li><code>float min</code>: The minimum range value (inclusive)</li> <li><code>float max</code>: The maximum range value (inclusive)</li> </ul> <p>Description:</p> <p>Returns a random <code>float</code> in the range [min, max].</p>"},{"location":"api-reference/#randfex","title":"<code>randfEx</code>","text":"<p>Signature:</p> <p><code>float randfEx()</code></p> <p>Description:</p> <p>Returns a random <code>float</code> in the range [0.0, 1.0).</p>"},{"location":"api-reference/#randi","title":"<code>randi</code>","text":"<p>Signature:</p> <p><code>int randi(int min, int max)</code></p> <p>Arguments:</p> <ul> <li><code>int min</code>: The minimum range value (inclusive)</li> <li><code>int max</code>: The maximum range value (inclusive)</li> </ul> <p>Description:</p> <p>Returns a random <code>int</code> in the range [min, max].</p>"},{"location":"api-reference/#randiex","title":"<code>randiEx</code>","text":"<p>Signature:</p> <p><code>int randiEx()</code></p> <p>Description:</p> <p>Returns an <code>int</code> with individually randomized bits.</p>"},{"location":"api-reference/#randomize","title":"<code>randomize</code>","text":"<p>Signature:</p> <p><code>void randomize()</code></p> <p>Description:</p> <p>Initializes the random number generator with a weak seed.</p> <p>It is not strictly necessary to call this function on init, as the system will initialize RNG when a cart is ran.</p>"},{"location":"api-reference/#randomizeex","title":"<code>randomizeEx</code>","text":"<p>Signature:</p> <p><code>void randomizeEx(int seed)</code></p> <p>Arguments:</p> <ul> <li><code>int seed</code>: Initialization value for RNG</li> </ul> <p>Description:</p> <p>Initializes the random number generator with seed.</p> <p>Identical seeds will produce the same sequence of numbers.</p>"},{"location":"api-reference/#round","title":"<code>round</code>","text":"<p>Signature:</p> <p><code>float round(float x)</code></p> <p>Arguments:</p> <ul> <li><code>float x</code>: Input value</li> </ul> <p>Description:</p> <p>Returns x rounded toward to the nearest whole number.</p> <p>Halfway cases are rounded away from zero.</p>"},{"location":"api-reference/#signf","title":"<code>signf</code>","text":"<p>Signature:</p> <p><code>float signf(float x)</code></p> <p>Arguments:</p> <ul> <li><code>float x</code>: Input value</li> </ul> <p>Description:</p> <p>Returns the sign of the <code>float</code> x.</p> <p>If x &lt; 0, returns -1.</p> <p>If x &gt; 0, returns 1.</p> <p>If x == 0, returns 0.</p>"},{"location":"api-reference/#signi","title":"<code>signi</code>","text":"<p>Signature:</p> <p><code>int signi(int x)</code></p> <p>Arguments:</p> <ul> <li><code>int x</code>: Input value</li> </ul> <p>Description:</p> <p>Returns the sign of the <code>int</code> x.</p> <p>If x &lt; 0, returns -1.</p> <p>If x &gt; 0, returns 1.</p> <p>If x == 0, returns 0.</p>"},{"location":"api-reference/#sin","title":"<code>sin</code>","text":"<p>Signature:</p> <p><code>float sin(float x)</code></p> <p>Arguments:</p> <ul> <li><code>float x</code>: Input value</li> </ul> <p>Description:</p> <p>Returns the sine of x.</p> <p>Return value will be in the range [-1.0, 1.0].</p>"},{"location":"api-reference/#wrapf","title":"<code>wrapf</code>","text":"<p>Signature:</p> <p><code>float wrapf(float x, float min, float max)</code></p> <p>Arguments:</p> <ul> <li><code>float x</code>: The value to wrap</li> <li><code>float min</code>: The minimum range value</li> <li><code>float max</code>: The maximum range value (exclusive)</li> </ul> <p>Description:</p> <p>Returns a <code>float</code> value within the range [min, max).</p> <p>If x is &lt; min or x &gt;= max, it wraps around to the other end of the range.</p>"},{"location":"api-reference/#wrapi","title":"<code>wrapi</code>","text":"<p>Signature:</p> <p><code>int wrapi(int x, int min, int max)</code></p> <p>Arguments:</p> <ul> <li><code>int x</code>: The value to wrap</li> <li><code>int min</code>: The minimum range value</li> <li><code>int max</code>: The maximum range value (exclusive)</li> </ul> <p>Description:</p> <p>Returns an <code>int</code> value within the range [min, max).</p> <p>If x is &lt; min or x &gt;= max, it wraps around to the other end of the range.</p>"},{"location":"api-reference/#vectors","title":"Vectors","text":""},{"location":"api-reference/#cam3dforward","title":"<code>cam3DForward</code>","text":"<p>Signature:</p> <p><code>vec3 cam3DForward(int camera)</code></p> <p>Arguments:</p> <ul> <li><code>int camera</code>: Index of the 3D camera to use [0-3]</li> </ul> <p>Description:</p> <p>Returns a 3D vector pointing forward in camera's local space.</p>"},{"location":"api-reference/#cam3dright","title":"<code>cam3DRight</code>","text":"<p>Signature:</p> <p><code>vec3 cam3DRight(int camera)</code></p> <p>Arguments:</p> <ul> <li><code>int camera</code>: Index of the 3D camera to use [0-3]</li> </ul> <p>Description:</p> <p>Returns a 3D vector pointing rightward in camera's local space.</p>"},{"location":"api-reference/#vec2angle","title":"<code>vec2Angle</code>","text":"<p>Signature:</p> <p><code>float vec2Angle(vec2 a, vec2 b)</code></p> <p>Arguments:</p> <ul> <li><code>vec2 a</code>: First input vector</li> <li><code>vec2 b</code>: Second input vector</li> </ul> <p>Description:</p> <p>Returns the angle (in degrees) from a to b.</p>"},{"location":"api-reference/#vec2cross","title":"<code>vec2Cross</code>","text":"<p>Signature:</p> <p><code>float vec2Cross(vec2 a, vec2 b)</code></p> <p>Arguments:</p> <ul> <li><code>vec2 a</code>: First input vector</li> <li><code>vec2 b</code>: Second input vector</li> </ul> <p>Description:</p> <p>Returns the cross product of a and b.</p> <p>This value is computed as <code>(a.x * b.y - a.y * b.x)</code>.</p>"},{"location":"api-reference/#vec2direction","title":"<code>vec2Direction</code>","text":"<p>Signature:</p> <p><code>vec2 vec2Direction(vec2 a, vec2 b)</code></p> <p>Arguments:</p> <ul> <li><code>vec2 a</code>: Start vector</li> <li><code>vec2 b</code>: End vector</li> </ul> <p>Description:</p> <p>Returns a normalized 2D vector pointing from a to b.</p>"},{"location":"api-reference/#vec2distance","title":"<code>vec2Distance</code>","text":"<p>Signature:</p> <p><code>float vec2Distance(vec2 a, vec2 b)</code></p> <p>Arguments:</p> <ul> <li><code>vec2 a</code>: First input vector</li> <li><code>vec2 b</code>: Second input vector</li> </ul> <p>Description:</p> <p>Returns the distance between a and b.</p>"},{"location":"api-reference/#vec2distancesq","title":"<code>vec2DistanceSq</code>","text":"<p>Signature:</p> <p><code>float vec2DistanceSq(vec2 a, vec2 b)</code></p> <p>Arguments:</p> <ul> <li><code>vec2 a</code>: First input vector</li> <li><code>vec2 b</code>: Second input vector</li> </ul> <p>Description:</p> <p>Returns the squared distance between a and b.</p> <p>This function is less costly to compute than <code>vec2Distance()</code>.</p> <p>As such, it is recommended to use this function when exact distance is not needed.</p>"},{"location":"api-reference/#vec2dot","title":"<code>vec2Dot</code>","text":"<p>Signature:</p> <p><code>float vec2Dot(vec2 a, vec2 b)</code></p> <p>Arguments:</p> <ul> <li><code>vec2 a</code>: First input vector</li> <li><code>vec2 b</code>: Second input vector</li> </ul> <p>Description:</p> <p>Returns the dot product of a and b.</p> <p>Use this function to compare the angle between two 2D vectors.</p> <p>For un-normalized vectors:</p> <ul> <li>Returns 0 when the angle is 90 degrees</li> <li>Returns a negative value when the angle is greater than 90 degrees</li> <li>Returns a positive value when the angle is less than 90 degrees</li> </ul> <p>For normalized vectors:</p> <ul> <li>Returns a value in the range [-1.0, 1.0]; -1.0 for a 180 degree angle and 1.0 when a and b are aligned.</li> </ul>"},{"location":"api-reference/#vec2down","title":"<code>vec2Down</code>","text":"<p>Signature:</p> <p><code>vec2 vec2Down()</code></p> <p>Description:</p> <p>Returns a <code>vec2</code> with the value <code>vec2(0.0, -1.0)</code>.</p>"},{"location":"api-reference/#vec2invert","title":"<code>vec2Invert</code>","text":"<p>Signature:</p> <p><code>vec2 vec2Invert(vec2 v)</code></p> <p>Arguments:</p> <ul> <li><code>vec2 v</code>: The vector to invert</li> </ul> <p>Description:</p> <p>Returns the inverse of the v.</p> <p>Equivelent to <code>vec2(1.0 / v.x, 1.0 / v.y)</code>.</p>"},{"location":"api-reference/#vec2left","title":"<code>vec2Left</code>","text":"<p>Signature:</p> <p><code>vec2 vec2Left()</code></p> <p>Description:</p> <p>Returns a <code>vec2</code> with the value <code>vec2(-1.0, 0.0)</code>.</p>"},{"location":"api-reference/#vec2length","title":"<code>vec2Length</code>","text":"<p>Signature:</p> <p><code>float vec2Length(vec2 v)</code></p> <p>Arguments:</p> <ul> <li><code>vec2 v</code>: The vector to get the length of</li> </ul> <p>Description:</p> <p>Returns the length (magnitude) of v.</p>"},{"location":"api-reference/#vec2lengthsq","title":"<code>vec2LengthSq</code>","text":"<p>Signature:</p> <p><code>float vec2LengthSq(vec2 v)</code></p> <p>Arguments:</p> <ul> <li><code>vec2 v</code>: The vector to get the length of</li> </ul> <p>Description:</p> <p>Returns the squared length (squared magnitude) of v.</p> <p>This function is less costly to compute than vec2length().</p> <p>As such, it is recommended to use this function when exact magnitude is not needed. (i.e. comparing vectors)</p>"},{"location":"api-reference/#vec2lerp","title":"<code>vec2Lerp</code>","text":"<p>Signature:</p> <p><code>vec2 vec2Lerp(vec2 start, vec2 end, float amount)</code></p> <p>Arguments:</p> <ul> <li><code>vec2 start</code>: Start vector</li> <li><code>vec2 end</code>: Destination vector</li> <li><code>float amount</code>: Amount to interpolate by (1.0 = 100%)</li> </ul> <p>Description:</p> <p>Returns the linear interpolation between start and end.</p>"},{"location":"api-reference/#vec2movetoward","title":"<code>vec2MoveToward</code>","text":"<p>Signature:</p> <p><code>vec2 vec2MoveToward(vec2 start, vec2 end, float distance)</code></p> <p>Arguments:</p> <ul> <li><code>vec2 start</code>: Starting vector</li> <li><code>vec2 end</code>: Destination vector</li> <li><code>float distance</code>: Maximum distance to travel</li> </ul> <p>Description:</p> <p>Returns the 2D vector start after being moved toward end by the given distance.</p> <p>If distance is greater than the amount required to reach end, returns end.</p>"},{"location":"api-reference/#vec2normalize","title":"<code>vec2Normalize</code>","text":"<p>Signature:</p> <p><code>vec2 vec2Normalize(vec2 v)</code></p> <p>Arguments:</p> <ul> <li><code>vec2 v</code>: The vector to normalize</li> </ul> <p>Description:</p> <p>Returns a 2D vector that points in the same direction as v, but has a length (magnitude) of 1.0.</p>"},{"location":"api-reference/#vec2one","title":"<code>vec2One</code>","text":"<p>Signature:</p> <p><code>vec2 vec2One()</code></p> <p>Description:</p> <p>Returns a <code>vec2</code> with the value <code>vec2(1.0, 1.0)</code>.</p>"},{"location":"api-reference/#vec2reflect","title":"<code>vec2Reflect</code>","text":"<p>Signature:</p> <p><code>vec2 vec2Reflect(vec2 v, vec2 normal)</code></p> <p>Arguments:</p> <ul> <li><code>vec2 v</code>: The vector to reflect</li> <li><code>vec2 normal</code>: The normal vector to reflect off of</li> </ul> <p>Description:</p> <p>Returns the 2D vector v reflected off of the normal vector.</p>"},{"location":"api-reference/#vec2right","title":"<code>vec2Right</code>","text":"<p>Signature:</p> <p><code>vec2 vec2Right()</code></p> <p>Description:</p> <p>Returns a <code>vec2</code> with the value <code>vec2(1.0, 0.0)</code>.</p>"},{"location":"api-reference/#vec2rotate","title":"<code>vec2Rotate</code>","text":"<p>Signature:</p> <p><code>vec2 vec2Rotate(vec2 v, float angle)</code></p> <p>Arguments:</p> <ul> <li><code>vec2 v</code>: The starting vector</li> <li><code>vec2 angle</code>: The angle to rotate by (in degrees)</li> </ul> <p>Description:</p> <p>Returns the 2D vector v rotated by the given angle.</p>"},{"location":"api-reference/#vec2up","title":"<code>vec2Up</code>","text":"<p>Signature:</p> <p><code>vec2 vec2Up()</code></p> <p>Description:</p> <p>Returns a <code>vec2</code> with the value <code>vec2(0.0, 1.0)</code>.</p>"},{"location":"api-reference/#vec2zero","title":"<code>vec2Zero</code>","text":"<p>Signature:</p> <p><code>vec2 vec2Zero()</code></p> <p>Description:</p> <p>Returns a <code>vec2</code> with the value <code>vec2(0.0, 0.0)</code>.</p>"},{"location":"api-reference/#vec3angle","title":"<code>vec3Angle</code>","text":"<p>Signature:</p> <p><code>float vec3Angle(vec3 a, vec3 b)</code></p> <p>Arguments:</p> <ul> <li><code>vec3 a</code>: First input vector</li> <li><code>vec3 b</code>: Second input vector</li> </ul> <p>Description:</p> <p>Returns the angle (in degrees) from a to b.</p>"},{"location":"api-reference/#vec3back","title":"<code>vec3Back</code>","text":"<p>Signature:</p> <p><code>vec3 vec3Back()</code></p> <p>Description:</p> <p>Returns a <code>vec3</code> with the value <code>vec3(0.0, 0.0, 1.0)</code>.</p>"},{"location":"api-reference/#vec3cross","title":"<code>vec3Cross</code>","text":"<p>Signature:</p> <p><code>float vec3Cross(vec3 a, vec3 b)</code></p> <p>Arguments:</p> <ul> <li><code>vec3 a</code>: First input vector</li> <li><code>vec3 b</code>: Second input vector</li> </ul> <p>Description:</p> <p>Returns the cross product of a and b.</p>"},{"location":"api-reference/#vec3direction","title":"<code>vec3Direction</code>","text":"<p>Signature:</p> <p><code>vec3 vec3Direction(vec3 a, vec3 b)</code></p> <p>Arguments:</p> <ul> <li><code>vec3 a</code>: Start vector</li> <li><code>vec3 b</code>: End vector</li> </ul> <p>Description:</p> <p>Returns a normalized 3D vector pointing from a to b.</p>"},{"location":"api-reference/#vec3distance","title":"<code>vec3Distance</code>","text":"<p>Signature:</p> <p><code>float vec3Distance(vec3 a, vec3 b)</code></p> <p>Arguments:</p> <ul> <li><code>vec3 a</code>: First input vector</li> <li><code>vec3 b</code>: Second input vector</li> </ul> <p>Description:</p> <p>Returns the distance between a and b.</p>"},{"location":"api-reference/#vec3distancesq","title":"<code>vec3DistanceSq</code>","text":"<p>Signature:</p> <p><code>float vec3DistanceSq(vec3 a, vec3 b)</code></p> <p>Arguments:</p> <ul> <li><code>vec3 a</code>: First input vector</li> <li><code>vec3 b</code>: Second input vector</li> </ul> <p>Description:</p> <p>Returns the squared distance between a and b.</p> <p>This function is less costly to compute than <code>vec3Distance()</code>.</p> <p>As such, it is recommended to use this function when exact distance is not needed.</p>"},{"location":"api-reference/#vec3dot","title":"<code>vec3Dot</code>","text":"<p>Signature:</p> <p><code>float vec3Dot(vec3 a, vec3 b)</code></p> <p>Arguments:</p> <ul> <li><code>vec3 a</code>: First input vector</li> <li><code>vec3 b</code>: Second input vector</li> </ul> <p>Description:</p> <p>Returns the dot product of a and b.</p> <p>Use this function to compare the angle between two 3D vectors.</p> <p>For un-normalized vectors:</p> <ul> <li>Returns 0 when the angle is 90 degrees.</li> <li>Returns a negative value when the angle is greater than 90 degrees.</li> <li>Returns a positive value when the angle is less than 90 degrees.</li> </ul> <p>For normalized vectors:</p> <ul> <li>Returns a value in the range [-1.0, 1.0]; -1.0 for a 180 degree angle and 1.0 when a and b are aligned.</li> </ul>"},{"location":"api-reference/#vec3down","title":"<code>vec3Down</code>","text":"<p>Signature:</p> <p><code>vec3 vec3Down()</code></p> <p>Description:</p> <p>Returns a <code>vec3</code> with the value <code>vec3(0.0, 1.0, 0.0)</code>.</p>"},{"location":"api-reference/#vec3forward","title":"<code>vec3Forward</code>","text":"<p>Signature:</p> <p><code>vec3 vec3Forward()</code></p> <p>Description:</p> <p>Returns a <code>vec3</code> with the value <code>vec3(0.0, 0.0, -1.0)</code>.</p>"},{"location":"api-reference/#vec3invert","title":"<code>vec3Invert</code>","text":"<p>Signature:</p> <p><code>vec3 vec3Invert(vec3 v)</code></p> <p>Arguments:</p> <ul> <li><code>vec3 v</code>: The vector to invert</li> </ul> <p>Description:</p> <p>Returns the inverse of v.</p> <p>Equivelent to <code>vec3(1.0 / v.x, 1.0 / v.y, 1.0 / v,z)</code>.</p>"},{"location":"api-reference/#vec3left","title":"<code>vec3Left</code>","text":"<p>Signature:</p> <p><code>vec3 vec3Left()</code></p> <p>Description:</p> <p>Returns a <code>vec3</code> with the value <code>vec3(-1.0, 0.0, 0.0)</code>.</p>"},{"location":"api-reference/#vec3length","title":"<code>vec3Length</code>","text":"<p>Signature:</p> <p><code>float vec3Length(vec3 v)</code></p> <p>Arguments:</p> <ul> <li><code>vec3 v</code>: The vector to get the length of</li> </ul> <p>Description:</p> <p>Returns the length (magnitude) of v.</p>"},{"location":"api-reference/#vec3lengthsq","title":"<code>vec3LengthSq</code>","text":"<p>Signature:</p> <p><code>float vec3LengthSq(vec3 v)</code></p> <p>Arguments:</p> <ul> <li><code>vec3 v</code>: The vector to get the length of</li> </ul> <p>Description:</p> <p>Returns the squared length (squared magnitude) of v.</p> <p>This function is less costly to compute than <code>vec3Length()</code>.</p> <p>As such, it is recommended to use this function when exact magnitude is not needed. (i.e. comparing vectors)</p>"},{"location":"api-reference/#vec3lerp","title":"<code>vec3Lerp</code>","text":"<p>Signature:</p> <p><code>vec2 vec3Lerp(vec3 start, vec3 end, float amount)</code></p> <p>Arguments:</p> <ul> <li><code>vec3 start</code>: Start vector</li> <li><code>vec3 end</code>: Destination vector</li> <li><code>float amount</code>: Amount to interpolate by (1.0 = 100%)</li> </ul> <p>Description:</p> <p>Returns the linear interpolation between start and end.</p>"},{"location":"api-reference/#vec3movetoward","title":"<code>vec3MoveToward</code>","text":"<p>Signature:</p> <p><code>vec3 vec3MoveToward(vec3 start, vec3 end, float distance)</code></p> <p>Arguments:</p> <ul> <li><code>vec3 start</code>: The starting vector</li> <li><code>vec3 end</code>: The destination vector</li> <li><code>float distance</code>: The maximum distance to travel</li> </ul> <p>Description:</p> <p>Returns the 3D vector start after being moved toward end by the given distance.</p> <p>If distance is greater than the amount required to reach end, returns end.</p>"},{"location":"api-reference/#vec3normalize","title":"<code>vec3Normalize</code>","text":"<p>Signature:</p> <p><code>vec3 vec3Normalize(vec3 v)</code></p> <p>Arguments:</p> <ul> <li><code>vec3 v</code>: The vector to normalize</li> </ul> <p>Description:</p> <p>Returns a 3D vector that points in the same direction as v, but has a length (magnitude) of 1.0.</p>"},{"location":"api-reference/#vec3one","title":"<code>vec3One</code>","text":"<p>Signature:</p> <p><code>vec3 vec3One()</code></p> <p>Description:</p> <p>Returns a <code>vec3</code> with the value <code>vec3(1.0, 1.0, 1.0)</code>.</p>"},{"location":"api-reference/#vec3reflect","title":"<code>vec3Reflect</code>","text":"<p>Signature:</p> <p><code>vec3 vec3Reflect(vec3 v, vec3 normal)</code></p> <p>Arguments:</p> <ul> <li><code>vec3 v</code>: The vector to reflect</li> <li><code>vec3 normal</code>: The normal vector to reflect off of</li> </ul> <p>Description:</p> <p>Returns the 3D vector v reflected off of the normal vector.</p>"},{"location":"api-reference/#vec3right","title":"<code>vec3Right</code>","text":"<p>Signature:</p> <p><code>vec3 vec3Right()</code></p> <p>Description:</p> <p>Returns a <code>vec3</code> with the value <code>vec3(1.0, 0.0, 0.0)</code>.</p>"},{"location":"api-reference/#vec3rotate","title":"<code>vec3Rotate</code>","text":"<p>Signature:</p> <p><code>vec3 vec3Rotate(vec3 v, vec3 axis, float angle)</code></p> <p>Arguments:</p> <ul> <li><code>vec2 v</code>: The starting vector</li> <li><code>vec2 axis</code>: The axis to rotate along</li> <li><code>vec2 angle</code>: The angle to rotate by (in degrees)</li> </ul> <p>Description:</p> <p>Returns the 3D vector v rotated along the given axis by the given angle.</p>"},{"location":"api-reference/#vec3toscreen","title":"<code>vec3ToScreen</code>","text":"<p>Signature:</p> <p><code>vec2 vec3ToScreen(vec3 v, int camera)</code></p> <p>Arguments:</p> <ul> <li><code>vec3 v</code>: The vector to project</li> <li><code>int camera</code>: The index of the 3D camera to use for the projection [0-3]</li> </ul> <p>Description:</p> <p>Returns a 2D vector containing the screen coordinates of the 3D vector v, as viewed from the perspective of the given 3D camera.</p>"},{"location":"api-reference/#vec3up","title":"<code>vec3Up</code>","text":"<p>Signature:</p> <p><code>vec3 vec3Up()</code></p> <p>Description:</p> <p>Returns a <code>vec3</code> with the value <code>vec3(0.0, -1.0, 0.0)</code>.</p>"},{"location":"api-reference/#vec3zero","title":"<code>vec3Zero</code>","text":"<p>Signature:</p> <p><code>vec3 vec3Zero()</code></p> <p>Description:</p> <p>Returns a <code>vec3</code> with the value <code>vec3(0.0, 0.0, 0.0)</code>.</p>"},{"location":"api-reference/#matrices","title":"Matrices","text":""},{"location":"api-reference/#matrixadd","title":"<code>matrixAdd</code>","text":"<p>Signature:</p> <p><code>...</code></p> <p>Arguments:</p> <ul> <li><code>...</code></li> </ul> <p>Description:</p> <p>...</p>"},{"location":"api-reference/#matrixidentity","title":"<code>matrixIdentity</code>","text":"<p>Signature:</p> <p><code>matrix matrixIdentity()</code></p> <p>Description:</p> <p>Returns an identity matrix. (a matrix with no transformations applied)</p>"},{"location":"api-reference/#matrixinvert","title":"<code>matrixInvert</code>","text":"<p>Signature:</p> <p><code>...</code></p> <p>Arguments:</p> <ul> <li><code>...</code></li> </ul> <p>Description:</p> <p>...</p>"},{"location":"api-reference/#matrixlookat","title":"<code>matrixLookAt</code>","text":"<p>Signature:</p> <p><code>...</code></p> <p>Arguments:</p> <ul> <li><code>...</code></li> </ul> <p>Description:</p> <p>...</p>"},{"location":"api-reference/#matrixmultiply","title":"<code>matrixMultiply</code>","text":"<p>Signature:</p> <p><code>...</code></p> <p>Arguments:</p> <ul> <li><code>...</code></li> </ul> <p>Description:</p> <p>...</p>"},{"location":"api-reference/#matrixrotate","title":"<code>matrixRotate</code>","text":"<p>Signature:</p> <p><code>...</code></p> <p>Arguments:</p> <ul> <li><code>...</code></li> </ul> <p>Description:</p> <p>...</p>"},{"location":"api-reference/#matrixscale","title":"<code>matrixScale</code>","text":"<p>Signature:</p> <p><code>...</code></p> <p>Arguments:</p> <ul> <li><code>...</code></li> </ul> <p>Description:</p> <p>...</p>"},{"location":"api-reference/#matrixsubtract","title":"<code>matrixSubtract</code>","text":"<p>Signature:</p> <p><code>...</code></p> <p>Arguments:</p> <ul> <li><code>...</code></li> </ul> <p>Description:</p> <p>...</p>"},{"location":"api-reference/#matrixtranslate","title":"<code>matrixTranslate</code>","text":"<p>Signature:</p> <p><code>...</code></p> <p>Arguments:</p> <ul> <li><code>...</code></li> </ul> <p>Description:</p> <p>...</p>"},{"location":"api-reference/#matrixtranspose","title":"<code>matrixTranspose</code>","text":"<p>Signature:</p> <p><code>...</code></p> <p>Arguments:</p> <ul> <li><code>...</code></li> </ul> <p>Description:</p> <p>...</p>"},{"location":"api-reference/#input","title":"Input","text":""},{"location":"api-reference/#getmousedelta","title":"<code>getMouseDelta</code>","text":"<p>Signature:</p> <p><code>vec2 getMouseDelta()</code></p> <p>Description:</p> <p>Returns a 2D vector containing the distance the mouse has moved since the last frame.</p>"},{"location":"api-reference/#getmousedrag","title":"<code>getMouseDrag</code>","text":"<p>Signature:</p> <p><code>vec2 getMouseDrag(int button)</code></p> <p>Arguments:</p> <ul> <li><code>int button</code>: The mouse button to check [0-2]</li> </ul> <p>Description:</p> <p>Returns a 2D vector containing the distance the mouse has been dragged since the given mouse button was pressed.</p> <p>button must be one of the following values:</p> Constant Value <code>BTN_MOUSE_LEFT</code> <code>0</code> <code>BTN_MOUSE_RIGHT</code> <code>1</code> <code>BTN_MOUSE_MIDDLE</code> <code>2</code>"},{"location":"api-reference/#getmouselock","title":"<code>getMouseLock</code>","text":"<p>Signature:</p> <p><code>int getMouseLock()</code></p> <p>Description:</p> <p>Returns 1 if the mouse is currently locked. Otherwise, returns 0.</p>"},{"location":"api-reference/#getmouseposition","title":"<code>getMousePosition</code>","text":"<p>Signature:</p> <p><code>vec2 getMousePosition()</code></p> <p>Description:</p> <p>Returns a 2D vector containing the mouse's screen coordinates.</p>"},{"location":"api-reference/#getmousewheel","title":"<code>getMouseWheel</code>","text":"<p>Signature:</p> <p><code>int getMouseWheel()</code></p> <p>Description:</p> <p>Returns 1 if the mouse wheel is being scrolled up.</p> <p>Returns -1 if the mouse wheel is being scrolled down.</p> <p>Otherwise, returns 0.</p>"},{"location":"api-reference/#held","title":"<code>held</code>","text":"<p>Signature:</p> <p><code>int held(int player, int button)</code></p> <p>Arguments:</p> <ul> <li><code>int player</code>: The player to check [0-3]</li> <li><code>int button</code>: The button to check [0-13]</li> </ul> <p>Description:</p> <p>Returns 1 if the given player is holding the given button. Otherwise, returns 0.</p> <p>button must be one of the following values:</p> Constant Value <code>BTN_UP</code> <code>0</code> <code>BTN_DOWN</code> <code>1</code> <code>BTN_LEFT</code> <code>2</code> <code>BTN_RIGHT</code> <code>3</code> <code>BTN_TRIANGLE</code> <code>4</code> <code>BTN_CROSS</code> <code>5</code> <code>BTN_SQUARE</code> <code>6</code> <code>BTN_CIRCLE</code> <code>7</code> <code>BTN_L1</code> <code>8</code> <code>BTN_L2</code> <code>9</code> <code>BTN_R1</code> <code>10</code> <code>BTN_R2</code> <code>11</code> <code>BTN_SELECT</code> <code>12</code> <code>BTN_START</code> <code>13</code>"},{"location":"api-reference/#mousedragging","title":"<code>mouseDragging</code>","text":"<p>Signature:</p> <p><code>int mouseDragging(int button)</code></p> <p>Arguments:</p> <ul> <li><code>int button</code>: The mouse button to check [0-2]</li> </ul> <p>Description:</p> <p>Returns 1 if the given mouse button has been held for at least 1 frame, and the mouse has moved since being held.</p> <p>Otherwise, returns 0.</p> <p>button must be one of the following values:</p> Constant Value <code>BTN_MOUSE_LEFT</code> <code>0</code> <code>BTN_MOUSE_RIGHT</code> <code>1</code> <code>BTN_MOUSE_MIDDLE</code> <code>2</code>"},{"location":"api-reference/#mouseheld","title":"<code>mouseHeld</code>","text":"<p>Signature:</p> <p><code>int mouseHeld(int button)</code></p> <p>Arguments:</p> <ul> <li><code>int button</code>: The mouse button to check [0-2]</li> </ul> <p>Description:</p> <p>Returns 1 if the given mouse button is being held.</p> <p>Otherwise, returns 0.</p> <p>button must be one of the following values:</p> Constant Value <code>BTN_MOUSE_LEFT</code> <code>0</code> <code>BTN_MOUSE_RIGHT</code> <code>1</code> <code>BTN_MOUSE_MIDDLE</code> <code>2</code>"},{"location":"api-reference/#mousepressed","title":"<code>mousePressed</code>","text":"<p>Signature:</p> <p><code>int mousePressed(int button)</code></p> <p>Arguments:</p> <ul> <li><code>int button</code>: The mouse button to check [0-2]</li> </ul> <p>Description:</p> <p>Returns 1 if the given mouse button has been pressed this frame.</p> <p>Otherwise, returns 0.</p> <p>button must be one of the following values:</p> Constant Value <code>BTN_MOUSE_LEFT</code> <code>0</code> <code>BTN_MOUSE_RIGHT</code> <code>1</code> <code>BTN_MOUSE_MIDDLE</code> <code>2</code>"},{"location":"api-reference/#mousereleased","title":"<code>mouseReleased</code>","text":"<p>Signature:</p> <p><code>int mouseReleased(int button)</code></p> <p>Arguments:</p> <ul> <li><code>int button</code>: The mouse button to check [0-2]</li> </ul> <p>Description:</p> <p>Returns 1 if the given mouse button has been released this frame.</p> <p>Otherwise, returns 0.</p> <p>button must be one of the following values:</p> Constant Value <code>BTN_MOUSE_LEFT</code> <code>0</code> <code>BTN_MOUSE_RIGHT</code> <code>1</code> <code>BTN_MOUSE_MIDDLE</code> <code>2</code>"},{"location":"api-reference/#pressed","title":"<code>pressed</code>","text":"<p>Signature:</p> <p><code>int pressed(int player, int button)</code></p> <p>Arguments:</p> <ul> <li><code>int player</code>: The player to check [0-3]</li> <li><code>int button</code>: The button to check [0-13]</li> </ul> <p>Description:</p> <p>Returns 1 if the given player has pressed the given button this frame.</p> <p>Otherwise, returns 0.</p> <p>button must be one of the following values:</p> Constant Value <code>BTN_UP</code> <code>0</code> <code>BTN_DOWN</code> <code>1</code> <code>BTN_LEFT</code> <code>2</code> <code>BTN_RIGHT</code> <code>3</code> <code>BTN_TRIANGLE</code> <code>4</code> <code>BTN_CROSS</code> <code>5</code> <code>BTN_SQUARE</code> <code>6</code> <code>BTN_CIRCLE</code> <code>7</code> <code>BTN_L1</code> <code>8</code> <code>BTN_L2</code> <code>9</code> <code>BTN_R1</code> <code>10</code> <code>BTN_R2</code> <code>11</code> <code>BTN_SELECT</code> <code>12</code> <code>BTN_START</code> <code>13</code>"},{"location":"api-reference/#released","title":"<code>released</code>","text":"<p>Signature:</p> <p><code>int released(int player, int button)</code></p> <p>Arguments:</p> <ul> <li><code>int player</code>: The player to check [0-3]</li> <li><code>int button</code>: The button to check [0-13]</li> </ul> <p>Description:</p> <p>Returns 1 if the given player has released the given button this frame.</p> <p>Otherwise, returns 0.</p> <p>button must be one of the following values:</p> Constant Value <code>BTN_UP</code> <code>0</code> <code>BTN_DOWN</code> <code>1</code> <code>BTN_LEFT</code> <code>2</code> <code>BTN_RIGHT</code> <code>3</code> <code>BTN_TRIANGLE</code> <code>4</code> <code>BTN_CROSS</code> <code>5</code> <code>BTN_SQUARE</code> <code>6</code> <code>BTN_CIRCLE</code> <code>7</code> <code>BTN_L1</code> <code>8</code> <code>BTN_L2</code> <code>9</code> <code>BTN_R1</code> <code>10</code> <code>BTN_R2</code> <code>11</code> <code>BTN_SELECT</code> <code>12</code> <code>BTN_START</code> <code>13</code>"},{"location":"api-reference/#setmouselock","title":"<code>setMouseLock</code>","text":"<p>Signature:</p> <p><code>void setMouseLock(int lock)</code></p> <p>Arguments:</p> <ul> <li><code>int lock</code>: Lock setting [true/false]</li> </ul> <p>Description:</p> <p>If lock is true, hides and locks the mouse to the screen.</p> <p>If lock is false, shows and unlocks the mouse.</p>"},{"location":"api-reference/#graphics","title":"Graphics","text":""},{"location":"api-reference/#ambientcolor","title":"<code>ambientColor</code>","text":"<p>Signature:</p> <p><code>void ambientColor(int color)</code></p> <p>Arguments:</p> <ul> <li><code>int color</code>: The ambient light color to use (RGBA32 format)</li> </ul> <p>Description:</p> <p>Sets the current ambient lighting color.</p>"},{"location":"api-reference/#ambientfactor","title":"<code>ambientFactor</code>","text":"<p>Signature:</p> <p><code>void ambientFactor(float factor)</code></p> <p>Arguments:</p> <ul> <li><code>float factor</code>: Percentage of ambient light tinting [0.0-100.0]</li> </ul> <p>Description:</p> <p>Sets the current ambient light factor.</p> <p>The ambient factor is the percentage of tinting that objects will recieve from ambient lighting.</p>"},{"location":"api-reference/#beginmesh","title":"<code>beginMesh</code>","text":"<p>Signature:</p> <p><code>void beginMesh(int primitive)</code></p> <p>Arguments:</p> <ul> <li><code>int primitive</code>: The type of mesh primitive to construct [0-2]</li> </ul> <p>Description:</p> <p>Begins construction of a mesh using the given primitive type.</p> <p>primitive must be one of the following values:</p> Constant Value Description <code>MESH_LINES</code> 0 Construct line primitives (2 vertices each) <code>MESH_TRIANGLES</code> 1 Construct triangle primitives (3 vertices each) <code>MESH_QUADS</code> 2 Construct quad primitives (4 vertices each) <p>Must eventually be followed by a call to <code>endMesh()</code>.</p>"},{"location":"api-reference/#blendfactors","title":"<code>blendFactors</code>","text":"<p>Signature:</p> <p><code>void blendFactors(int src, int dest, int eq)</code></p> <p>Arguments:</p> <ul> <li><code>int src</code>: The new blending source factor to use [0-14]</li> <li><code>int dest</code>: The new blending destination factor to use [0-14]</li> <li><code>int eq</code>: The new blending equation to use [0-4]</li> </ul> <p>Description:</p> <p>Changes the current color blending factors and equations for both rgb and alpha.</p> <p>Must be called before <code>blendMode()</code>.</p> <p>Blend mode must be set to <code>BLEND_CUSTOM</code> (6) after this call.</p> <p>src and dest must be one of the following values:</p> Constant Value <code>FACTOR_ZERO</code> <code>0</code> <code>FACTOR_ONE</code> <code>1</code> <code>FACTOR_SRC_RGB</code> <code>2</code> <code>FACTOR_ONE_MINUS_SRC_RGB</code> <code>3</code> <code>FACTOR_DST_RGB</code> <code>4</code> <code>FACTOR_ONE_MINUS_DST_RGB</code> <code>5</code> <code>FACTOR_SRC_ALPHA</code> <code>6</code> <code>FACTOR_ONE_MINUS_SRC_ALPHA</code> <code>7</code> <code>FACTOR_DST_ALPHA</code> <code>8</code> <code>FACTOR_ONE_MINUS_DST_ALPHA</code> <code>9</code> <code>FACTOR_CONSTANT_RGB</code> <code>10</code> <code>FACTOR_ONE_MINUS_CONSTANT_RGB</code> <code>11</code> <code>FACTOR_CONSTANT_ALPHA</code> <code>12</code> <code>FACTOR_ONE_MINUS_CONSTANT_ALPHA</code> <code>13</code> <code>FACTOR_SRC_ALPHA_SATURATE</code> <code>14</code> <p>eq must be one of the following values:</p> Constant Value <code>EQ_ADD</code> <code>0</code> <code>EQ_SUBTRACT</code> <code>1</code> <code>EQ_SUBTRACT_REVERSE</code> <code>2</code> <code>EQ_MIN</code> <code>3</code> <code>EQ_MAX</code> <code>4</code>"},{"location":"api-reference/#blendfactorsex","title":"<code>blendFactorsEx</code>","text":"<p>Signature:</p> <p><code>void blendFactorsEx(int src_rgb, int dest_rgb, int src_alpha, int dest_alpha, int eq_rgb, int eq_alpha)</code></p> <p>Arguments:</p> <ul> <li><code>int src_rgb</code>: Blending source rgb factor to use [0-14]</li> <li><code>int dest_rgb</code>: Blending destination rgb factor to use [0-14]</li> <li><code>int src_alpha</code>: Blending source alpha factor to use [0-14]</li> <li><code>int dest_alpha</code>: Blending destination alpha factor to use [0-14]</li> <li><code>int eq_rgb</code>: Blending rgb equation to use [0-4]</li> <li><code>int eq_alpha</code>: Blending alpha equation to use [0-4]</li> </ul> <p>Description:</p> <p>Changes the current blending factors and equations for rgb and alpha individually.</p> <p>Must be called before <code>blendMode()</code>.</p> <p>Blend mode must be set to <code>BLEND_CUSTOM_EX</code> (7) after this call.</p> <p>See <code>blendFactors()</code> for a list of factors and equations.</p>"},{"location":"api-reference/#blendmode","title":"<code>blendMode</code>","text":"<p>Signature:</p> <p><code>void blendMode(int mode)</code></p> <p>Arguments:</p> <ul> <li><code>int mode</code>: The new blending mode to use [0-7]</li> </ul> <p>Description:</p> <p>Changes the current color blending mode setting.    </p> <p>mode must be one of the following values:</p> Constant Value <code>BLEND_ALPHA</code> <code>0</code> <code>BLEND_ADD</code> <code>1</code> <code>BLEND_MULTIPLY</code> <code>2</code> <code>BLEND_ADD_ALT</code> <code>3</code> <code>BLEND_SUBTRACT</code> <code>4</code> <code>BLEND_PREMULTIPLY</code> <code>5</code> <code>BLEND_CUSTOM</code> <code>6</code> <code>BLEND_CUSTOM_EX</code> <code>7</code>"},{"location":"api-reference/#camera2d","title":"<code>camera2D</code>","text":"<p>Signature:</p> <p><code>void camera2D(int camera)</code></p> <p>Arguments:</p> <ul> <li><code>int camera</code>: Index of the 2D camera to use [0-3]</li> </ul> <p>Description:</p> <p>Configures the topmost matrix on the stack to match the view of the given 2D camera.</p>"},{"location":"api-reference/#camera3d","title":"<code>camera3D</code>","text":"<p>Signature:</p> <p><code>void camera3D(int camera)</code></p> <p>Arguments:</p> <ul> <li><code>int camera</code>: Index of the 3D camera to use [0-3]</li> </ul> <p>Description:</p> <p>Configures the topmost matrix on the stack to match the view of the given 3D camera.</p> <p>Before the call to draw() each frame, an implicit call to <code>camera3d(0)</code> is made.</p>"},{"location":"api-reference/#clear","title":"<code>clear</code>","text":"<p>Signature:</p> <p><code>void clear(int flags)</code></p> <p>Arguments:</p> <ul> <li><code>int flags</code>: The buffers to clear</li> </ul> <p>Description:</p> <p>Clears the rendering buffers specified by flags.</p> <p>flags is a 3-bit bitmask, each bit corresponding to a render buffer.</p> <p>The following table lists built-in constants that can be used as flags values:</p> Constant Value Description <code>CLEAR_NONE</code> Binary: <code>0b000</code> (Decimal: <code>0</code>) Do not clear any buffers <code>CLEAR_COLOR</code> Binary: <code>0b100</code> (Decimal: <code>4</code>) Clear the color buffer (pixel buffer drawn to the screen) <code>CLEAR_DEPTH</code> Binary: <code>0b010</code> (Decimal: <code>2</code>) Clear the depth buffer (buffer containing each pixel's distance from the camera) <code>CLEAR_STENCIL</code> Binary: <code>0b001</code> (Decimal: <code>1</code>) Clear the stencil buffer (8-bit buffer used to mask to-be-drawn pixels) <code>CLEAR_ALL</code> Binary: <code>0b111</code> (Decimal: <code>7</code>) Clear all buffers <p>Constants can be bitwise OR'd to clear different combinations of buffers:</p> <pre><code>clear(CLEAR_DEPTH | CLEAR_STENCIL); // clear depth and stencil buffers, but not color\n</code></pre>"},{"location":"api-reference/#clearcolor","title":"<code>clearColor</code>","text":"<p>Signature:</p> <p><code>void clearColor(int color)</code></p> <p>Arguments:</p> <ul> <li><code>int color</code>: The new clear color to use. (RGBA32 format)</li> </ul> <p>Description:</p> <p>Sets the value to fill the color buffer with when <code>clear()</code> is called with the <code>CLEAR_COLOR</code> flag enabled.</p> <p>The default clear color is black. (<code>0x000000FF</code>)</p>"},{"location":"api-reference/#cleardepth","title":"<code>clearDepth</code>","text":"<p>Signature:</p> <p><code>void clearDepth(float depth)</code></p> <p>Arguments:</p> <ul> <li><code>float depth</code>: The new clear depth to use. [0.0-1.0]</li> </ul> <p>Description:</p> <p>Sets the value to fill the depth buffer with when <code>clear()</code> is called with the <code>CLEAR_DEPTH</code> flag enabled.</p> <p>The default clear depth is 1.0.</p>"},{"location":"api-reference/#clearstencil","title":"<code>clearStencil</code>","text":"<p>Signature:</p> <p><code>void clearStencil(int stencil)</code></p> <p>Arguments:</p> <ul> <li><code>int stencil</code>: The new clear stencil to use. [0x00-0xFF]</li> </ul> <p>Description:</p> <p>Sets the value to fill the stencil buffer with when <code>clear()</code> is called with the <code>CLEAR_STENCIL</code> flag enabled.</p> <p>The default clear stencil is <code>0x00</code>.</p>"},{"location":"api-reference/#colormask","title":"<code>colorMask</code>","text":"<p>Signature:</p> <p><code>void colorMask(int flags)</code></p> <p>Arguments:</p> <ul> <li><code>int flags</code>: Color channel flags</li> </ul> <p>Description:</p> <p>Enables/disables writing to the color buffer on a per-channel basis.</p> <p>flags is a 4-bit bitmask, each bit corresponding to a color channel.</p> <p>The following table lists built-in constants that can be used as flags values:</p> Constant Value Description <code>COLOR_NONE</code> Binary: <code>0b0000</code> (Decimal: <code>0</code>) Disable all writing to the color buffer <code>COLOR_R</code> Binary: <code>0b1000</code> (Decimal: <code>8</code>) Enable writing the red color channel to the color buffer <code>COLOR_G</code> Binary: <code>0b0100</code> (Decimal: <code>4</code>) Enable writing the green color channel to the color buffer <code>COLOR_B</code> Binary: <code>0b0010</code> (Decimal: <code>2</code>) Enable writing the blue color channel to the color buffer <code>COLOR_A</code> Binary: <code>0b0001</code> (Decimal: <code>1</code>) Enable writing the alpha color channel to the color buffer <code>COLOR_ALL</code> Binary: <code>0b1111</code> (Decimal: <code>15</code>) Enable all writing to the color buffer <p>Constants can be bitwise OR'd to enable different combinations of channels:</p> <pre><code>colorMask(COLOR_R | COLOR_A); // write only to the red and alpha channels of the color buffer\n</code></pre>"},{"location":"api-reference/#cullmode","title":"<code>cullMode</code>","text":"<p>Signature:</p> <p><code>void cullMode(int mode)</code></p> <p>Arguments:</p> <ul> <li><code>int mode</code>: The new face culling mode to use [0-2]`</li> </ul> <p>Description:</p> <p>Changes the current face culling mode setting.</p> <p>mode must be one of the following values:</p> Constant Value Description <code>CULL_BACK</code> 0 Cull backfaces <code>CULL_FRONT</code> 1 Cull frontfaces <code>CULL_NONE</code> 2 Disable face culling"},{"location":"api-reference/#depthfunc","title":"<code>depthFunc</code>","text":"<p>Signature:</p> <p><code>void depthFunc(int func)</code></p> <p>Arguments:</p> <ul> <li><code>int func</code>: The new depth function to use [0-7]</li> </ul> <p>Description:</p> <p>Sets the function used during depth testing.</p> <p>func must be one of the following values:</p> Constant Value Description <code>FUNC_LESS</code> 0 Depth test passes if new depth &lt; current depth <code>FUNC_LEQUAL</code> 1 Depth test passes if new depth &lt;= current depth <code>FUNC_GREATER</code> 2 Depth test passes if new depth &gt; current depth <code>FUNC_GEQUAL</code> 3 Depth test passes if new depth &gt;= current depth <code>FUNC_EQUAL</code> 4 Depth test passes if new depth == current depth <code>FUNC_NOTEQUAL</code> 5 Depth test passes if new depth != current depth <code>FUNC_ALWAYS</code> 6 Depth test always passes <code>FUNC_NEVER</code> 7 Depth test never passes"},{"location":"api-reference/#depthmask","title":"<code>depthMask</code>","text":"<p>Signature:</p> <p><code>void depthMask(int enable)</code></p> <p>Arguments:</p> <ul> <li><code>int enable</code>: Depth buffer writing flag [true/false]</li> </ul> <p>Description:</p> <p>Enables/disables writing to the depth buffer.</p>"},{"location":"api-reference/#depthtest","title":"<code>depthTest</code>","text":"<p>Signature:</p> <p><code>void depthTest(int enable)</code></p> <p>Arguments:</p> <ul> <li><code>int enable</code>: Depth testing flag [true/false]</li> </ul> <p>Description:</p> <p>Enables/disables depth testing.</p>"},{"location":"api-reference/#drawobj","title":"<code>drawObj</code>","text":"<p>Signature:</p> <p><code>void drawObj(int entry)</code></p> <p>Arguments:</p> <ul> <li><code>int entry</code>: <code>OBJMAP</code> entry to draw [0-511]</li> </ul> <p>Description:</p> <p>Renders the mesh defined by the <code>OBJMAP</code> entry at the index entry.</p> <p>If the <code>OBJMAP</code> entry is configured to point to collision data, it will not be rendered.</p>"},{"location":"api-reference/#drawobjex","title":"<code>drawObjEx</code>","text":"<p>Signature:</p> <p><code>void drawObjEx(int primitive, int start, int n)</code></p> <p>Arguments:</p> <ul> <li><code>int primitive</code>: The type of primitve to construct [0-2]</li> <li><code>int start</code>: The index of the first vertex in <code>OBJMEM</code> to draw [0-98303]</li> <li><code>int n</code>: The number of primitives to draw</li> </ul> <p>Description:</p> <p>Renders mesh data in <code>OBJMEM</code> according to the given parameters.</p> <p>primitive must be one of the following values:</p> Constant Value Description <code>MESH_LINES</code> 0 Construct line primitives (2 vertices each) <code>MESH_TRIANGLES</code> 1 Construct triangle primitives (3 vertices each) <code>MESH_QUADS</code> 2 Construct quad primitives (4 vertices each)"},{"location":"api-reference/#endmesh","title":"<code>endMesh</code>","text":"<p>Signature:</p> <p><code>void endMesh()</code></p> <p>Description:</p> <p>Finalizes the construction of a mesh.</p> <p>Must only be called after a matching call to <code>beginMesh()</code>.</p>"},{"location":"api-reference/#fogcolor","title":"<code>fogColor</code>","text":"<p>Signature:</p> <p><code>void fogColor(int color)</code></p> <p>Arguments:</p> <ul> <li><code>int color:</code> The fog color to use (RGBA32 format)</li> </ul> <p>Description:</p> <p>Sets the current fog tint color.</p>"},{"location":"api-reference/#fogend","title":"<code>fogEnd</code>","text":"<p>Signature:</p> <p><code>void fogEnd(float end);</code></p> <p>Arguments:</p> <ul> <li><code>float end:</code> The distance from the camera where the fog ends. [0.0-1000.0]</li> </ul> <p>Description:</p> <p>Sets the fog end distance setting.</p>"},{"location":"api-reference/#fogmode","title":"<code>fogMode</code>","text":"<p>Signature:</p> <p><code>void fogMode(int enabled)</code></p> <p>Arguments:</p> <ul> <li><code>int enabled:</code> Fog enable flag [true/false]</li> </ul> <p>Description:</p> <p>Enables/disables fog.</p> <p>If enabled is true, fog rendering will be enabled.</p> <p>Otherwise, fog rendering will be disabled.</p> <p>Fog is rendered by fading the color of geometry to the set fog color.</p> <p>The fog start setting determines how far from the camera the fade begins.</p> <p>The fog end setting is the distance from the camera where objects will be fully tinted to the fog color.</p>"},{"location":"api-reference/#fogstart","title":"<code>fogStart</code>","text":"<p>Signature:</p> <p><code>void fogStart(float start);</code></p> <p>Arguments:</p> <ul> <li><code>float start:</code> The distance from the camera to start rendering fog. [0.0-1000.0]</li> </ul> <p>Description:</p> <p>Sets the fog starting distance setting.</p>"},{"location":"api-reference/#frustum","title":"<code>frustum</code>","text":"<p>Signature:</p> <p><code>...</code></p> <p>Arguments:</p> <ul> <li><code>...</code></li> </ul> <p>Description:</p> <p>...</p>"},{"location":"api-reference/#getcam2d","title":"<code>getCam2D</code>","text":"<p>Signature:</p> <p><code>cam2d* getCam2D(int camera)</code></p> <p>Arguments:</p> <ul> <li><code>int camera: index of the 2D camera to get [0-3]</code></li> </ul> <p>Description:</p> <p>Returns a pointer to the given 2d camera.</p>"},{"location":"api-reference/#getcam3d","title":"<code>getCam3D</code>","text":"<p>Signature:</p> <p><code>cam3d* getCam3D(int camera)</code></p> <p>Arguments:</p> <ul> <li><code>int camera: index of the 3D camera to get [0-3]</code></li> </ul> <p>Description:</p> <p>Returns a pointer to the given 3d camera.</p>"},{"location":"api-reference/#getlight","title":"<code>getLight</code>","text":"<p>Signature:</p> <p><code>light* getLight(int light)</code></p> <p>Arguments:</p> <ul> <li><code>int light: index of the light to get [0-7]</code></li> </ul> <p>Description:</p> <p>Returns a pointer to the given light.</p>"},{"location":"api-reference/#getmodelviewmatrix","title":"<code>getModelViewMatrix</code>","text":"<p>Signature:</p> <p><code>matrix getModelViewMatrix()</code></p> <p>Description:</p> <p>Returns a copy of the topmost model-view matrix.</p>"},{"location":"api-reference/#getprojectionmatrix","title":"<code>getProjectionMatrix</code>","text":"<p>Signature:</p> <p><code>matrix getProjectionMatrix()</code></p> <p>Description:</p> <p>Returns a copy of the topmost projection matrix.</p>"},{"location":"api-reference/#gettopmatrix","title":"<code>getTopMatrix</code>","text":"<p>Signature:</p> <p><code>matrix getTopMatrix()</code></p> <p>Description:</p> <p>Returns a copy of the topmost matrix of the current matrix stack.</p>"},{"location":"api-reference/#identity","title":"<code>identity</code>","text":"<p>Signature:</p> <p><code>void identity()</code></p> <p>Description:</p> <p>Resets the topmost matrix of the current matrix stack to an identity matrix.</p> <p>(a matrix with no transformations applied)</p>"},{"location":"api-reference/#lightingmode","title":"<code>lightingMode</code>","text":"<p>Signature:</p> <p><code>void lightingMode(int mode)</code></p> <p>Arguments:</p> <ul> <li><code>int mode: the lighting mode to use [true/false]</code></li> </ul> <p>Description:</p> <p>Enables/disables vertex lighting.</p> <p>If mode is true, lighting will be enabled.</p> <p>Otherwise, lighting will be disabled.</p> <p>Vertex lighting changes vertex colors to simulate lighting.</p> <p>When lighting is enabled, meshcolor() calls will be ignored.</p> <p>Ambient lighting is also calculated when lighting is enabled.</p> <p>Ambient lighting is a form of light that every object</p> <p>Recieves equally.</p>"},{"location":"api-reference/#lookat","title":"<code>lookAt</code>","text":"<p>Signature:</p> <p><code>...</code></p> <p>Arguments:</p> <ul> <li><code>...</code></li> </ul> <p>Description:</p> <p>...</p>"},{"location":"api-reference/#meshcolor","title":"<code>meshColor</code>","text":"<p>Signature:</p> <p><code>void meshColor(int color)</code></p> <p>Arguments:</p> <ul> <li><code>int color: the color to use for the current vertex (RGBA32 format)</code></li> </ul> <p>Description:</p> <p>Submits the tint color for the current mesh vertex.</p> <p>Vertex colors can be used to tint the texture of a mesh.</p> <p>The colors of each vertex are blended across the mesh surface.</p> <p>Vertex colors are multiplied with texture pixel colors,</p> <p>So a vertex color of pure white will result in the</p> <p>Original pixel color.</p> <p>If lighting is enabled, this function does nothing.</p>"},{"location":"api-reference/#meshnormal","title":"<code>meshNormal</code>","text":"<p>Signature:</p> <p><code>void meshNormal(vec3 normal)</code></p> <p>Arguments:</p> <ul> <li><code>vec3 normal: the 3D normal vector to use for the current vertex</code></li> </ul> <p>Description:</p> <p>Submits the 3d normal vector for the current mesh vertex.</p> <p>The vector must be normalized. (normal must have a length of 1)</p> <p>Normal vectors are used when calculating lighting.</p> <p>A vertex with a normal vector pointing toward a light will recieve more</p> <p>Light than one with a normal vector pointing away from the light.</p> <p>If lighting is not enabled, this function does nothing.</p>"},{"location":"api-reference/#meshuv","title":"<code>meshUV</code>","text":"<p>Signature:</p> <p><code>void meshUV(vec2 uv)</code></p> <p>Arguments:</p> <ul> <li><code>vec2 uv: the 2D texture coordinates to use for the current vertex</code></li> </ul> <p>Description:</p> <p>Submits the 2d texture coordinates for the current mesh vertex.</p> <p>(0.0, 0.0) corresponds to the top-left corner of the texture.</p> <p>(1.0, 1.0) corresponds to the bottom-right corner of the texture.</p> <p>The normal range for uv coordinates is (0.0, 0.0) to (1.0, 1.0),</p> <p>Values outside the 0.0-1.0 range will be treated differently</p> <p>Depending on the current texture mode. (see settexturemode())</p>"},{"location":"api-reference/#meshvertex","title":"<code>meshVertex</code>","text":"<p>Signature:</p> <p><code>void meshVertex(vec3 v)</code></p> <p>Arguments:</p> <ul> <li><code>vec3 v: the 3D coordinates to use for the current vertex</code></li> </ul> <p>Description:</p> <p>Submits the 3d coordinates for the current mesh vertex and</p> <p>Finalizes the vertex.</p> <p>This function should be called after all other desired vertex properties</p> <p>(uv, color, normal) have been submitted.</p>"},{"location":"api-reference/#meshvertex2d","title":"<code>meshVertex2D</code>","text":"<p>Signature:</p> <p><code>void meshVertex2D(vec2 v)</code></p> <p>Arguments:</p> <ul> <li><code>vec2 v: the 2D screen coordinates to use for the current vertex</code></li> </ul> <p>Description:</p> <p>Submits the 2d coordinates for the current mesh vertex and</p> <p>Finalizes the vertex.</p> <p>This function should be called after all other desired vertex properties</p> <p>(uv, color, normal) have been submitted.</p>"},{"location":"api-reference/#multiplytopmatrix","title":"<code>multiplyTopMatrix</code>","text":"<p>Signature:</p> <p><code>void multiplyTopMatrix(matrix m)</code></p> <p>Arguments:</p> <ul> <li><code>matrix m: the matrix to multiply by</code></li> </ul> <p>Description:</p> <p>Multiplies the topmost matrix of the current stack by the given matrix.</p>"},{"location":"api-reference/#ortho","title":"<code>ortho</code>","text":"<p>Signature:</p> <p><code>...</code></p> <p>Arguments:</p> <ul> <li><code>...</code></li> </ul> <p>Description:</p> <p>...</p>"},{"location":"api-reference/#polygonmode","title":"<code>polygonMode</code>","text":"<p>Signature:</p> <p><code>...</code></p> <p>Arguments:</p> <ul> <li><code>...</code></li> </ul> <p>Description:</p> <p>...</p>"},{"location":"api-reference/#popmatrix","title":"<code>popMatrix</code>","text":"<p>Signature:</p> <p><code>void popMatrix()</code></p> <p>Description:</p> <p>Pops the topmost matrix off of the current matrix stack.</p>"},{"location":"api-reference/#print2d","title":"<code>print2D</code>","text":"<p>Signature:</p> <p><code>void print2D(int x, int y, int color, string fmt, ...)</code></p> <p>Arguments:</p> <ul> <li><code>int x : text screen x position</code></li> <li><code>int y : text screen y position</code></li> <li><code>int color : the text color to use (RGBA32 format)</code></li> <li><code>string fmt: format text string</code></li> <li><code>... : format values</code></li> </ul> <p>Description:</p> <p>Prints a formatted text string to the screen.</p> <p>Format specifiers:</p> <p>%%       literal '%' character</p> <p>%d or %i signed integer value</p> <p>%u       unsigned integer value</p> <p>%f       float value</p> <p>%x       lowercase hexidecimal integer value</p> <p>%x       uppercase hexidecimal integer value</p> <p>%v2      vec2 value</p> <p>%v3      vec3 value</p>"},{"location":"api-reference/#pushmatrix","title":"<code>pushMatrix</code>","text":"<p>Signature:</p> <p><code>void pushMatrix()</code></p> <p>Description:</p> <p>Pushes a copy of the current matrix to the top of the current matrix stack.</p>"},{"location":"api-reference/#rotate","title":"<code>rotate</code>","text":"<p>Signature:</p> <p><code>void rotate(vec3 v)</code></p> <p>Arguments:</p> <ul> <li><code>vec3 v: the vector to rotate by</code></li> </ul> <p>Description:</p> <p>Rotates the topmost matrix of the current matrix by the 3d vector v.</p> <p>Rotation angles must be in degrees.</p>"},{"location":"api-reference/#scale","title":"<code>scale</code>","text":"<p>Signature:</p> <p><code>void scale(vec3 v)</code></p> <p>Arguments:</p> <ul> <li><code>vec3 v: the vector to scale by</code></li> </ul> <p>Description:</p> <p>Scales the topmost matrix of the current matrix by the 3d vector v.</p>"},{"location":"api-reference/#scissor","title":"<code>scissor</code>","text":"<p>Signature:</p> <p><code>void scissor(int x, int y, int width, int height)</code></p> <p>Arguments:</p> <ul> <li><code>int x</code>: Scissor screen x position [0-479]</li> <li><code>int y</code>: Scissor screen y position [0-359]</li> <li><code>int width</code>: Scissor width [1-480]</li> <li><code>int height</code>: Scissor height [1-360]</li> </ul> <p>Description:</p> <p>Restricts all rendering to the rectangle defined by x, y, width, and height.</p> <p>Pixels outside of the rectangle will not be affected by any drawing commands.</p>"},{"location":"api-reference/#scissormode","title":"<code>scissorMode</code>","text":"<p>Signature:</p> <p><code>...</code></p> <p>Arguments:</p> <ul> <li><code>...</code></li> </ul> <p>Description:</p> <p>...</p>"},{"location":"api-reference/#setmodelviewmatrix","title":"<code>setModelViewMatrix</code>","text":"<p>Signature:</p> <p><code>void setModelViewMatrix(matrix m)</code></p> <p>Arguments:</p> <ul> <li><code>matrix m: the matrix to use</code></li> </ul> <p>Description:</p> <p>Sets the topmost model-view matrix to the given matrix.</p>"},{"location":"api-reference/#setprojectionmatrix","title":"<code>setProjectionMatrix</code>","text":"<p>Signature:</p> <p><code>void setProjectionMatrix(matrix m)</code></p> <p>Arguments:</p> <ul> <li><code>matrix m: the matrix to use</code></li> </ul> <p>Description:</p> <p>Sets the topmost projection matrix to the given matrix.</p>"},{"location":"api-reference/#sprite2d","title":"<code>sprite2D</code>","text":"<p>Signature:</p> <p><code>...</code></p> <p>Arguments:</p> <ul> <li><code>...</code></li> </ul> <p>Description:</p> <p>...</p>"},{"location":"api-reference/#sprite2dex","title":"<code>sprite2DEx</code>","text":"<p>Signature:</p> <p><code>...</code></p> <p>Arguments:</p> <ul> <li><code>...</code></li> </ul> <p>Description:</p> <p>...</p>"},{"location":"api-reference/#stencilfunc","title":"<code>stencilFunc</code>","text":"<p>Signature:</p> <p><code>...</code></p> <p>Arguments:</p> <ul> <li><code>...</code></li> </ul> <p>Description:</p> <p>...</p>"},{"location":"api-reference/#stencilmask","title":"<code>stencilMask</code>","text":"<p>Signature:</p> <p><code>...</code></p> <p>Arguments:</p> <ul> <li><code>...</code></li> </ul> <p>Description:</p> <p>...</p>"},{"location":"api-reference/#stencilmode","title":"<code>stencilMode</code>","text":"<p>Signature:</p> <p><code>...</code></p> <p>Arguments:</p> <ul> <li><code>...</code></li> </ul> <p>Description:</p> <p>...</p>"},{"location":"api-reference/#stencilop","title":"<code>stencilOp</code>","text":"<p>Signature:</p> <p><code>...</code></p> <p>Arguments:</p> <ul> <li><code>...</code></li> </ul> <p>Description:</p> <p>...</p>"},{"location":"api-reference/#texture","title":"<code>texture</code>","text":"<p>Signature:</p> <p><code>void texture(int x, int y, int width, int height)</code></p> <p>Arguments:</p> <ul> <li><code>int x : texture window x position [0-1023]</code></li> <li><code>int y : texture window y position [0-1023]</code></li> <li><code>int width : texture window width [1-256]</code></li> <li><code>int height: texture window height [1-256]</code></li> </ul> <p>Description:</p> <p>Changes the window of texture memory to use as the current texture.</p> <p>A maximum texture size of 256x256 can be specified.</p> <p>Texture uv coordinates will be mapped to the specified texture window.</p>"},{"location":"api-reference/#texturemode","title":"<code>textureMode</code>","text":"<p>Signature:</p> <p><code>void textureMode(int mode)</code></p> <p>Arguments:</p> <ul> <li><code>int mode: the new texture mode to use [0-2]</code></li> </ul> <p>Description:</p> <p>Changes the current texture mode setting.</p> <p>Mode must be one of the following values:</p> <p>0: repeat texture (default)</p> <p>1: clamp texture to edges</p> <p>2: disable texturing</p> <p>Modes 0 and 1 determine whether uvs outside of the 0.0-1.0 range</p> <p>Will cause the texture to be repeated accross a surface, or</p> <p>If uvs should be clamped to the 0.0-1.0 range.</p> <p>Mode 2 will ignore texture pixel colors and output</p> <p>Pure white instead. useful when used with vertex colors.</p>"},{"location":"api-reference/#translate","title":"<code>translate</code>","text":"<p>Signature:</p> <p><code>void translate(vec3 v)</code></p> <p>Arguments:</p> <ul> <li><code>vec3 v: the vector to translate by</code></li> </ul> <p>Description:</p> <p>Translates the topmost matrix of the current matrix by the 3d vector v.</p>"},{"location":"api-reference/#viewport","title":"<code>viewport</code>","text":"<p>Signature:</p> <p><code>void viewport(int x, int y, int width, int height)</code></p> <p>Arguments:</p> <ul> <li><code>int x</code>: Viewport screen x position [0-479]</li> <li><code>int y</code>: Viewport screen y position [0-359]</li> <li><code>int width</code>: Viewport width [1-480]</li> <li><code>int height</code>: Viewport height [1-360]</li> </ul> <p>Description:</p> <p>Defines the tranformation of coordinates of pixels to render into screen coordinates.</p> <p>By default, pixels are rendered at 1:1 screen coordinates, but this function allows rendering output to be scaled to the rectangle defined by x, y, width, and height.</p>"},{"location":"api-reference/#audio","title":"Audio","text":""},{"location":"api-reference/#gettrackbpm","title":"<code>getTrackBPM</code>","text":"<p>Signature:</p> <p><code>...</code></p> <p>Arguments:</p> <ul> <li><code>...</code></li> </ul> <p>Description:</p> <p>...</p>"},{"location":"api-reference/#gettrackpan","title":"<code>getTrackPan</code>","text":"<p>Signature:</p> <p><code>...</code></p> <p>Arguments:</p> <ul> <li><code>...</code></li> </ul> <p>Description:</p> <p>...</p>"},{"location":"api-reference/#gettrackvolume","title":"<code>getTrackVolume</code>","text":"<p>Signature:</p> <p><code>...</code></p> <p>Arguments:</p> <ul> <li><code>...</code></li> </ul> <p>Description:</p> <p>...</p>"},{"location":"api-reference/#mutetrack","title":"<code>muteTrack</code>","text":"<p>Signature:</p> <p><code>...</code></p> <p>Arguments:</p> <ul> <li><code>...</code></li> </ul> <p>Description:</p> <p>...</p>"},{"location":"api-reference/#mutetracks","title":"<code>muteTracks</code>","text":"<p>Signature:</p> <p><code>...</code></p> <p>Arguments:</p> <ul> <li><code>...</code></li> </ul> <p>Description:</p> <p>...</p>"},{"location":"api-reference/#pausetrack","title":"<code>pauseTrack</code>","text":"<p>Signature:</p> <p><code>...</code></p> <p>Arguments:</p> <ul> <li><code>...</code></li> </ul> <p>Description:</p> <p>...</p>"},{"location":"api-reference/#pausetracks","title":"<code>pauseTracks</code>","text":"<p>Signature:</p> <p><code>...</code></p> <p>Arguments:</p> <ul> <li><code>...</code></li> </ul> <p>Description:</p> <p>...</p>"},{"location":"api-reference/#playpattern","title":"<code>playPattern</code>","text":"<p>Signature:</p> <p><code>...</code></p> <p>Arguments:</p> <ul> <li><code>...</code></li> </ul> <p>Description:</p> <p>...</p>"},{"location":"api-reference/#playsong","title":"<code>playSong</code>","text":"<p>Signature:</p> <p><code>...</code></p> <p>Arguments:</p> <ul> <li><code>...</code></li> </ul> <p>Description:</p> <p>...</p>"},{"location":"api-reference/#playtrack","title":"<code>playTrack</code>","text":"<p>Signature:</p> <p><code>...</code></p> <p>Arguments:</p> <ul> <li><code>...</code></li> </ul> <p>Description:</p> <p>...</p>"},{"location":"api-reference/#playwav","title":"<code>playWav</code>","text":"<p>Signature:</p> <p><code>...</code></p> <p>Arguments:</p> <ul> <li><code>...</code></li> </ul> <p>Description:</p> <p>...</p>"},{"location":"api-reference/#playwavex","title":"<code>playWavEx</code>","text":"<p>Signature:</p> <p><code>...</code></p> <p>Arguments:</p> <ul> <li><code>...</code></li> </ul> <p>Description:</p> <p>...</p>"},{"location":"api-reference/#resumetrack","title":"<code>resumeTrack</code>","text":"<p>Signature:</p> <p><code>...</code></p> <p>Arguments:</p> <ul> <li><code>...</code></li> </ul> <p>Description:</p> <p>...</p>"},{"location":"api-reference/#resumetracks","title":"<code>resumeTracks</code>","text":"<p>Signature:</p> <p><code>...</code></p> <p>Arguments:</p> <ul> <li><code>...</code></li> </ul> <p>Description:</p> <p>...</p>"},{"location":"api-reference/#settrackbpm","title":"<code>setTrackBPM</code>","text":"<p>Signature:</p> <p><code>...</code></p> <p>Arguments:</p> <ul> <li><code>...</code></li> </ul> <p>Description:</p> <p>...</p>"},{"location":"api-reference/#settrackpan","title":"<code>setTrackPan</code>","text":"<p>Signature:</p> <p><code>...</code></p> <p>Arguments:</p> <ul> <li><code>...</code></li> </ul> <p>Description:</p> <p>...</p>"},{"location":"api-reference/#settrackvolume","title":"<code>setTrackVolume</code>","text":"<p>Signature:</p> <p><code>...</code></p> <p>Arguments:</p> <ul> <li><code>...</code></li> </ul> <p>Description:</p> <p>...</p>"},{"location":"api-reference/#stoptrack","title":"<code>stopTrack</code>","text":"<p>Signature:</p> <p><code>...</code></p> <p>Arguments:</p> <ul> <li><code>...</code></li> </ul> <p>Description:</p> <p>...</p>"},{"location":"api-reference/#stoptracks","title":"<code>stopTracks</code>","text":"<p>Signature:</p> <p><code>...</code></p> <p>Arguments:</p> <ul> <li><code>...</code></li> </ul> <p>Description:</p> <p>...</p>"},{"location":"api-reference/#unmutetrack","title":"<code>unmuteTrack</code>","text":"<p>Signature:</p> <p><code>...</code></p> <p>Arguments:</p> <ul> <li><code>...</code></li> </ul> <p>Description:</p> <p>...</p>"},{"location":"api-reference/#unmutetracks","title":"<code>unmuteTracks</code>","text":"<p>Signature:</p> <p><code>...</code></p> <p>Arguments:</p> <ul> <li><code>...</code></li> </ul> <p>Description:</p> <p>...</p>"},{"location":"api-reference/#physics","title":"Physics","text":""},{"location":"api-reference/#collide","title":"<code>collide</code>","text":"<p>Signature:</p> <p><code>...</code></p> <p>Arguments:</p> <ul> <li><code>...</code></li> </ul> <p>Description:</p> <p>...</p>"},{"location":"api-reference/#getraycastnormal","title":"<code>getRaycastNormal</code>","text":"<p>Signature:</p> <p><code>...</code></p> <p>Arguments:</p> <ul> <li><code>...</code></li> </ul> <p>Description:</p> <p>...</p>"},{"location":"api-reference/#getraycastpoint","title":"<code>getRaycastPoint</code>","text":"<p>Signature:</p> <p><code>...</code></p> <p>Arguments:</p> <ul> <li><code>...</code></li> </ul> <p>Description:</p> <p>...</p>"},{"location":"api-reference/#raycast","title":"<code>raycast</code>","text":"<p>Signature:</p> <p><code>...</code></p> <p>Arguments:</p> <ul> <li><code>...</code></li> </ul> <p>Description:</p> <p>...</p>"},{"location":"api-reference/#memory","title":"Memory","text":""},{"location":"api-reference/#alloc","title":"<code>alloc</code>","text":"<p>Signature:</p> <p><code>void* alloc(int size)</code></p> <p>Arguments:</p> <ul> <li><code>int size</code>: The amount of bytes to allocate</li> </ul> <p>Description:</p> <p>Allocates a heap memory block of at least size bytes and returns its address.</p> <p>Returns <code>null</code> if the allocation fails.</p>"},{"location":"api-reference/#free","title":"<code>free</code>","text":"<p>Signature:</p> <p><code>void free(void* block)</code></p> <p>Arguments:</p> <ul> <li><code>void* block</code>: Pointer to the block to free</li> </ul> <p>Description:</p> <p>Deallocates a heap memory block if block points to a block previously allocated by <code>alloc()</code>.</p> <p><code>free(null)</code> does nothing.</p>"},{"location":"api-reference/#initmemcard","title":"<code>initMemCard</code>","text":"<p>Signature:</p> <p><code>void initMemCard(string id)</code></p> <p>Arguments:</p> <ul> <li><code>string id: unique identifier for memory card data</code></li> </ul> <p>Description:</p> <p>Initializes the system's memory card memory range.</p> <p>Memory card data is stored in the address range 0x05800000 to 0x05800fff.</p> <p>Id is a string used to identify saved memory card data.</p> <p>Id must be between 1 and 16 characters long and may only contain</p> <p>The characters a-z, a-z, 0-9, and _</p> <p>If save data matching the given id exists, it will be loaded.</p> <p>Write bytes to the address range 0x05800000 to 0x05800fff to save</p> <p>Data to the memory card.</p>"},{"location":"api-reference/#loadobjbank","title":"<code>loadObjBank</code>","text":"<p>Signature:</p> <p><code>void loadObjBank(int bank)</code></p> <p>Arguments:</p> <ul> <li><code>int bank: index of the object bank to load [0-3]</code></li> </ul> <p>Description:</p> <p>Loads an object bank from the cartridge into system memory.</p> <p>System object data is stored in the address range</p> <p>0x00c00000 to 0x00f5ffff.</p>"},{"location":"api-reference/#loadseqbank","title":"<code>loadSeqBank</code>","text":"<p>Signature:</p> <p><code>void loadSeqBank(int bank)</code></p> <p>Arguments:</p> <ul> <li><code>int bank: index of the sequencer bank to load [0-7]</code></li> </ul> <p>Description:</p> <p>Loads a sequencer bank from the cartridge into system memory.</p> <p>System sequencer data is stored in the address range</p> <p>0x01700000 to 0x0173ffff.</p>"},{"location":"api-reference/#loadtexbank","title":"<code>loadTexBank</code>","text":"<p>Signature:</p> <p><code>void loadTexBank(int bank)</code></p> <p>Arguments:</p> <ul> <li><code>int bank: index of the texture bank to load [0-3]</code></li> </ul> <p>Description:</p> <p>Loads a texture bank from the cartridge into system memory.</p> <p>System texture data is stored in the address range</p> <p>0x00800000 to 0x00bfffff.</p>"},{"location":"api-reference/#loadwavbank","title":"<code>loadWavBank</code>","text":"<p>Signature:</p> <p><code>void loadWavBank(int bank)</code></p> <p>Arguments:</p> <ul> <li><code>int bank: index of the wave bank to load [0-1]</code></li> </ul> <p>Description:</p> <p>Loads a wave bank from the cartridge into system memory.</p> <p>System wave data is stored in the address range</p> <p>0x01000000 to 0x016fffff.</p>"},{"location":"api-reference/#memcpy","title":"<code>memcpy</code>","text":"<p>Signature:</p> <p><code>void memcpy(void* destination, void* source, int n)</code></p> <p>Arguments:</p> <ul> <li><code>void* destination: the memory address to write to</code></li> <li><code>void* source : the memory address to read from</code></li> <li><code>int n : the amount of bytes to read</code></li> </ul> <p>Description:</p> <p>Copies n bytes from source to destination.</p> <p>Source and destination buffers may safely overlap.</p>"},{"location":"api-reference/#memset","title":"<code>memset</code>","text":"<p>Signature:</p> <p><code>void memset(void* destination, int n, int value)</code></p> <p>Arguments:</p> <ul> <li><code>void* destination: the memory address to write to</code></li> <li><code>int n : the amount of bytes to write</code></li> <li><code>int value : byte value to write</code></li> </ul> <p>Description:</p> <p>Copies the given byte value to the first n bytes</p> <p>Starting at the destination address.</p>"},{"location":"api-reference/#peek8","title":"<code>peek8</code>","text":"<p>Signature:</p> <p><code>int peek8(void* address)</code></p> <p>Arguments:</p> <ul> <li><code>void* address: memory pointer to read from</code></li> </ul> <p>Description:</p> <p>Returns the value of the byte at the given memory address.</p>"},{"location":"api-reference/#peek32","title":"<code>peek32</code>","text":"<p>Signature:</p> <p><code>int peek32(void* address)</code></p> <p>Arguments:</p> <ul> <li><code>void* address: memory pointer to read from</code></li> </ul> <p>Description:</p> <p>Returns the 32-bit integer value starting at the given memory address.</p>"},{"location":"api-reference/#poke8","title":"<code>poke8</code>","text":"<p>Signature:</p> <p><code>void poke8(void* address, int value)</code></p> <p>Arguments:</p> <ul> <li><code>void* address: memory pointer to write to</code></li> <li><code>int value : byte value to write</code></li> </ul> <p>Description:</p> <p>Writes the given byte to the given memory address.</p>"},{"location":"api-reference/#poke32","title":"<code>poke32</code>","text":"<p>Signature:</p> <p><code>void poke32(void* address, int value)</code></p> <p>Arguments:</p> <ul> <li><code>void* address: memory pointer to write to</code></li> <li><code>int value : 32-bit integer value to write</code></li> </ul> <p>Description:</p> <p>Writes the 32-bit integer to the given memory address.</p>"},{"location":"api-reference/#realloc","title":"<code>realloc</code>","text":"<p>Signature:</p> <p><code>void* realloc(void* block, int size)</code></p> <p>Arguments:</p> <ul> <li><code>void* block</code>: Pointer to the block to reallocate</li> <li><code>int size</code>: The new amount of bytes to allocate</li> </ul> <p>Description:</p> <p>Reallocates the heap memory block pointed to by block to at least size bytes and returns its address.</p> <p>The contents of block are copied to the newly allocated block.</p> <p>Returns <code>null</code> if the reallocation fails.</p>"},{"location":"api-reference/#strcat","title":"<code>strcat</code>","text":"<p>Signature:</p> <p><code>string strcat(string a, string b)</code></p> <p>Arguments:</p> <ul> <li><code>string a</code>: First string to concatenate</li> <li><code>string b</code>: Second string to concatenate</li> </ul> <p>Description:</p> <p>Returns a new <code>string</code> containing the contents of a concatenated with the contents of b.</p> <p>A heap memory block is allocated to contain the new <code>string</code>.</p> <p>If allocation fails, returns a <code>string</code> with the value <code>string(0, null)</code>.</p>"},{"location":"api-reference/#strdup","title":"<code>strdup</code>","text":"<p>Signature:</p> <p><code>string strdup(string s)</code></p> <p>Arguments:</p> <ul> <li><code>string s</code>: The string to duplicate</li> </ul> <p>Description:</p> <p>Returns a new <code>string</code> containing a copy of the contents of s.</p> <p>A heap memory block is allocated to contain the new <code>string</code>.</p> <p>If allocation fails, returns a <code>string</code> with the value <code>string(0, null)</code>.</p>"},{"location":"api-reference/#misc","title":"Misc","text":""},{"location":"api-reference/#time","title":"<code>time</code>","text":"<p>Signature:</p> <p><code>float time()</code></p> <p>Description:</p> <p>Returns the number of seconds that the current cart has been running.</p>"},{"location":"api-reference/#vargc","title":"<code>vargc</code>","text":"<p>Signature:</p> <p><code>int vargc()</code></p> <p>Description:</p> <p>Returns the remaining number of vararg bytes for a vararg function.</p> <p>Must only be called from a vararg function.</p>"},{"location":"api-reference/#vargv","title":"<code>vargv</code>","text":"<p>Signature:</p> <p><code>void* vargv(int offset)</code></p> <p>Arguments:</p> <ul> <li><code>int offset: the number of bytes to advance the vararg pointer</code></li> </ul> <p>Description:</p> <p>Returns a pointer to the current vararg argument and advances the</p> <p>Vararg pointer by $offset bytes.</p> <p>Must only be called from a vararg function.</p>"},{"location":"building/","title":"Building","text":"<p>To build ERA-3D, you must first install Nelua. Follow the installation instructions on the Nelua website.</p> <p>Once Nelua is installed, build and install the following C libraries:</p> <ul> <li>raylib v5.0</li> <li>BlipKit</li> <li>zip</li> </ul> <p>Once all dependencies are installed, clone this repository and run the following commands:</p> <pre><code>cd .../ERA-3D/\nnelua --release src/main.nelua -o era-3d\n</code></pre> <p>You should now have the <code>era-3d</code> executable. move <code>era-3d</code> and the <code>assets</code> directory to the desired install location.</p>"},{"location":"configuration/","title":"Configuration","text":""},{"location":"configuration/#introduction","title":"Introduction","text":"<p>ERA-3D stores configuration data, carts, and memory card data in its own folders on the filesystem.</p>"},{"location":"configuration/#data-directories","title":"Data Directories","text":"<p>The ERA-3D data directory can be found in the following places:</p> WindowsLinux <pre><code>C:\\Users\\username\\AppData\\Roaming\\era-3d\n</code></pre> <pre><code>~/.era-3d\n</code></pre> <p>Inside the <code>era-3d</code> directory are the following items:</p> <ul> <li><code>carts</code> directory: default location of saved cart files</li> <li><code>memcards</code> directory: used for storing memcard data files</li> <li><code>config.json</code>: ERA-3D configuration file</li> </ul>"},{"location":"configuration/#config-file-settings","title":"Config File Settings","text":"<p>The following table lists all available configuration settings for <code>config.json</code>.</p> Setting Accepted Values Default Value Description <code>log_level</code> 0-7 7 Raylib event log filter level (see Log Levels table below) <code>vsync</code> <code>true</code>/<code>false</code> <code>true</code> VSYNC enable flag <code>highdpi</code> <code>true</code>/<code>false</code> <code>true</code> HIGHDPI enable flag <code>draw_fps</code> <code>true</code>/<code>false</code> <code>false</code> Debug FPS counter display flag <code>crt_blur</code> <code>true</code>/<code>false</code> <code>true</code> CRT blur effect flag <code>crt_noise</code> <code>true</code>/<code>false</code> <code>true</code> CRT static/noise effect flag <code>crt_scanlines</code> <code>true</code>/<code>false</code> <code>true</code> CRT scanline effect flag <p>The following table lists the possible values for the <code>log_level</code> setting.</p> <p>Levels are ranked, with each level filtering out all events of lower level value.</p> Log Level Description 0 Log all events 1 Log trace events and higher 2 Log debug events and higher 3 Log info events and higher 4 Log warning events and higher 5 Log error events and higher 6 Log fatal error events 7 Disable event logging"},{"location":"demos/","title":"Demos","text":""},{"location":"demos/#introduction","title":"Introduction","text":"<p>Several demos for ERA-3D are included in the following zip archive.</p> <p>These demos illustrate the usage of various systems and API functions.</p> <p>Demos Download</p>"},{"location":"demos/#installing-demos","title":"Installing Demos","text":"<p>To install the demo files, extract them from <code>demos.zip</code>.</p> <p>The demo files can be placed anywhere, but it is recommended to put them in ERA-3D's <code>carts</code> directory:</p> WindowsLinux <pre><code>C:\\Users\\username\\AppData\\Roaming\\era-3d\\carts\n</code></pre> <pre><code>~/.era-3d/carts\n</code></pre>"},{"location":"demos/#running-demos","title":"Running Demos","text":"<p>In ERA-3D, press Ctrl+O to open the Load Cart dialog, which should by default open to the ERA-3D <code>carts</code> directory.</p> <p>Highlight the demo file using Up/Down and press Enter to load it.</p> <p>Once the demo is loaded, run the cart by pressing Ctrl+R.</p>"},{"location":"era-c-overview/","title":"ERA-C Overview","text":""},{"location":"era-c-overview/#introduction","title":"Introduction","text":"<p>Warning</p> <p>This page assumes you are already familiar with basic programming concepts and data types.</p> <p>ERA-3D games are programmed in a scripting language called ERA-C. ERA-C is similar to C in many ways, but has a few key differences that are worth noting.</p> <p>If you are already familiar with C, see the Differences From C section.</p>"},{"location":"era-c-overview/#comments","title":"Comments","text":"<p>Comments in ERA-C follow the same syntax as C/C++.</p> <pre><code>// single-line comment\nint a = 32; // another comment\n/*\nmulti\nline\ncomment\n*/\n</code></pre> <p>Multi-line comments can be nested.</p> <pre><code>/*\n  this is a comment\n  /*\n    this is a nested comment\n  */\n  this is still a comment\n*/\n</code></pre>"},{"location":"era-c-overview/#variables","title":"Variables","text":"<p>Both local and global variables are declared using the pattern <code>&lt;data type&gt; &lt;name&gt; ;</code>.</p> <p>Variable names must start with a letter and can contain the characters <code>a-z, A-Z, 0-9, _</code></p> <pre><code>int my_int; // an int variable\nfloat my_float; // a float variable\n</code></pre> <p>Local variables (variables declared inside a function or loop scope) can be assigned a value when they are declared.</p> <pre><code>int foo = 42;\n</code></pre> <p>Global variables must be initialized inside of a function.</p> <p>The <code>init()</code> function is a good place for that. (See the Hook Functions section)</p>"},{"location":"era-c-overview/#primitive-types","title":"Primitive Types","text":"<p>Primitive types are data types built into the ERA-C compiler.</p>"},{"location":"era-c-overview/#int","title":"<code>int</code>","text":"<p><code>int</code> is a data type that is capable of storing positive and negative whole numbers.</p> <p>Specifically, they are 32-bit integers. Most operations treat them as signed integers, but some operators treat <code>int</code> values as unsigned.</p> <p>Integer literal values can be given in decimal form, but they can also be represented in hexadecimal and binary form using the <code>0x</code> and <code>0b</code> prefixes.</p> <p>Unlike C, leading zeros do not mean a number is in octal format.</p> <pre><code>int a = 24; // positive value\nint b = -24; // negative value\nint hex = 0xFF; // hexadecimal value (255)\nint binary = 0b10101010; // binary value (170)\n\n// to make large numbers easier to read, underscores can be inserted between digits.\nint big_number = 12_345_678;\n\n// character literals are also supported, and are interpreted as int values.\nint letter_e = 'E';\n</code></pre> <p>ERA-C has a special syntax for encoding note values used by the soundchip.</p> <p>The <code>0n</code> prefix followed by a note name (see list below) and an octave number (0-8) define a note.</p> <pre><code>int c_sharp_4 = 0nC#4; // soundchip note value (note C#, octave 4)\n</code></pre> <p>All valid note names are listed below. Notes can be written using upper or lower case.</p> <p><code>C, C#, D, D#, E, F, F#, G, G#, A, A#, B</code></p> <p><code>int</code>s support various arithmetic operations, as well as bitwise and logical ones.</p> <p><code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, and <code>%</code> are the addition, subtraction, multiplication, division, and modulus operators. They follow the same precedence rules as C.</p> <pre><code>int a = 2 + 2;\nint b = 5 - 3;\nint c = 9 * 100;\nint d = 10 / 2;\nint e = 10 % 5;\n</code></pre> <p>Info</p> <p>Dividing <code>int</code> values does not result in a fractional value, the fractional component is discarded instead.</p> <p><code>5 / 2</code> returns 2, not 2.5.</p> <p>ERA-C also supports bitwise operations for integers.</p> <pre><code>int a = ~0b00001111; // bitwise NOT: a = 0b11110000\nint b = 0b10101010 | 0b01010101; // bitwise OR: b = 0b11111111\nint c = 0b10101111 &amp; 0b00111100; // bitwise AND: c = 0b00101100\nint d = 0b11001100 ^ 0b10101010; // bitwise XOR: d = 0b01100110\nint e = 0b00001111 &lt;&lt; 2; // bitwise left shift: e = 0b00111100\nint f = 0b11110000 &gt;&gt; 4; // bitwise right shift (logical): f = 0b00001111\nint g = 0b10000000 &gt;&gt;&gt; 4; // bitwise right shift (arithmetic): f = 0b11111000\n</code></pre> <p>The logical and comparison operators return an integer value, so their result can be stored in an <code>int</code>.</p> <p>If the comparison is true, a value of 1 is returned. Otherwise, 0 is returned.</p> <pre><code>int a = 1 &lt; 2; // a = 1 (true)\nint b = 1 == 2; // b = 0 (false)\n</code></pre>"},{"location":"era-c-overview/#float","title":"<code>float</code>","text":"<p><code>float</code>s are 32-bit floating point values, meaning they are numbers with a fractional component.</p> <pre><code>float my_float = 2.5;\n</code></pre> <p><code>floats</code> support the <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, and <code>%</code> operators, as well as the comparison operators.</p>"},{"location":"era-c-overview/#vec2","title":"<code>vec2</code>","text":"<p><code>vec2</code> represents a 2D vector with <code>x</code> and <code>y</code> components.</p> <p><code>x</code> and <code>y</code> both have the <code>float</code> data type.</p> <pre><code>vec2 v = vec2(1.0, 2.0); // 2D vector with the value (x=1.0, y=2.0)\n\nv.x = 9.0; // assigning a new x value\nv.y = 0.25; // assigning a new y value\n</code></pre> <p>The following table lists special functions used to construct <code>vec2</code>s with common values:</p> Function <code>vec2</code> Return Value <code>vec2Zero()</code> <code>{0.0, 0.0}</code> (equivalent to <code>vec2()</code> with no arguments) <code>vec2One()</code> <code>{1.0, 1.0}</code> <code>vec2Up()</code> <code>{0.0, -1.0}</code> <code>vec2Down()</code> <code>{0.0, 1.0}</code> <code>vec2Left()</code> <code>{-1.0, 0.0}</code> <code>vec2Right()</code> <code>{1.0, 0.0}</code>"},{"location":"era-c-overview/#vec3","title":"<code>vec3</code>","text":"<p><code>vec3</code> represents a 3D vector with <code>x</code>, <code>y</code>, and <code>z</code> components.</p> <p><code>x</code>, <code>y</code>, and <code>z</code> all have the <code>float</code> data type.</p> <pre><code>vec3 v = vec3(1.0, 2.0, 3.0); // 3D vector with the value (x=1.0, y=2.0, z=3.0)\n\nv.x = 7.5; // assigning a new x value\nv.y = 0.75; // assigning a new y value\nv.z = 4.9; // assigning a new z value\n</code></pre> <p>The following table lists special functions used to construct <code>vec3</code>s with common values:</p> Function <code>vec3</code> Return Value <code>vec3Zero()</code> <code>{0.0, 0.0, 0.0}</code> (equivalent to <code>vec3()</code> with no arguments) <code>vec3One()</code> <code>{1.0, 1.0, 1.0}</code> <code>vec3Up()</code> <code>{0.0, 1.0, 0.0}</code> <code>vec3Down()</code> <code>{0.0, -1.0, 0.0}</code> <code>vec3Left()</code> <code>{-1.0, 0.0, 0.0}</code> <code>vec3Right()</code> <code>{1.0, 0.0, 0.0}</code> <code>vec3Forward()</code> <code>{0.0, 0.0, -1.0}</code> <code>vec3Back()</code> <code>{0.0, 0.0, 1.0}</code> <p>Both <code>vec2</code> and <code>vec3</code> support addition, subtraction, multiplication, and division.</p> <p>Vector types cannot be mixed in vector arithmetic, only vectors of the same dimensions can be added, subtracted, etc.</p> <p>During a arithmetic operation, the individual members of the vector are operated on. For example, when adding two <code>vec2</code> values, the result will be <code>vec2(a.x + b.x, a.y + b.y)</code>. The same pattern applies to all arithmetic operators.</p> <pre><code>vec2 v2 = vec2(1.1, 2.2) + vec2(3.3, 4.4); // v2 = vec2(4.4, 6.6)\nvec3 v3 = vec3(1.1, 2.2, 3.3) + vec3(4.4, 5.5, 6.6); // v3 = vec3(5.5, 7.7, 9.9)\n</code></pre> <p>Vectors can also be multiplied and divided by <code>int</code> and <code>float</code> values. This will return a vector with each member having been multiplied/divided by the <code>int</code>/<code>float</code> value.</p> <pre><code>vec3 a = vec3(1.1, 2.2, 3.3) * 2; // a = vec3(2.2, 4.4, 6.6)\nvec2 b = vec2(5.0, 10.0) / 2.5; // b = vec2(2.0, 4.0)\n</code></pre> <p>Vectors support all comparison operators, and can only be compared with their same type.</p> <p>Comparing vectors compares each member pair, and the comparison is only true if all pairs satisfy the comparison.</p> <pre><code>vec2 a = vec2(10.0, 20.0);\nvec2 b = vec2(1.0, 2.0);\n\nint result = a &lt; b; // result = 1 (true), as a.x &lt; b.x and a.y &lt; b.y\n</code></pre>"},{"location":"era-c-overview/#string","title":"<code>string</code>","text":"<p>The <code>string</code> data type is used to hold text.</p> <p><code>string</code> literals must be enclosed within double-quotes (<code>\"</code>).</p> <pre><code>string text = \"hello world!\";\n</code></pre> <p>To fetch a character from the string, or to change a character, use the following expression: <code>&lt;variable&gt; [ &lt;index&gt; ];</code>.</p> <p>The characters of a string are zero-indexed, meaning that the first character is stored at index 0.</p> <pre><code>string text = \"hello world!\";\nint character = text[0]; // fetch a character\n</code></pre> <p>Internally, <code>string</code> is a struct (see the Structs section) that looks like this:</p> <pre><code>struct string {\n  int length;\n  void* data;\n};\n</code></pre> <p>Warning</p> <p>String literals allocate space in cartridge ROM to store their data, so trying to write characters into a <code>string</code> initialized using a literal will cause an error and halt the program.</p> <p>If a modifiable string is needed, a <code>string</code> struct can be manually created to point to somewhere in RAM.</p> <p>Strings support the <code>==</code> and <code>!=</code> operators. Two strings are considered equal if the following conditions are met:</p> <ol> <li>both strings are the same length</li> <li>both strings point to the same address or the characters in both strings match</li> </ol>"},{"location":"era-c-overview/#arrays","title":"Arrays","text":"<p>Arrays are essentially blocks of memory used to store a list of elements all of a particular data type. For example, you might have an array containing 10 <code>int</code> values, or an array containing 5 <code>vec2</code> values.</p> <p>Arrays are fixed in size, once they are declared the cannot be resized.</p> <pre><code>int my_array[10]; // declare an array of 10 ints\n</code></pre> <p>Access array elements using the pattern <code>&lt;array variable&gt; [ &lt;index&gt; ]</code>, where <code>&lt;index&gt;</code> is an integer value.</p> <p>Array values are zero-indexed; meaning the first element in the array is stored at index 0, the second at index 1, and so on.</p> <pre><code>int my_array[10];\nint x = my_array[0]; // get the first value stored in the array\nmy_array[1] = 99; // store a new value in the array at index 1\n</code></pre>"},{"location":"era-c-overview/#pointers","title":"Pointers","text":"<p>ERA-C supports pointers, which behave similarly to pointers in C. To declare a pointer to a type, put a <code>*</code> after the data type.</p> <pre><code>int* int_pointer; // pointer to an int\n</code></pre> <p>To obtain the memory address of a variable, use the address-of operator. (<code>&amp;</code>)</p> <pre><code>int x = 42; // normal int variable\nint* ptr = &amp;x; // ptr now contains the memory address of x \n</code></pre> <p>The unary dereference operator (<code>*</code>) can be used to fetch the value pointed to by a pointer.</p> <pre><code>int x = 42;\nint* ptr = &amp;x;\nint y = *ptr; // y now contains the same value as x\n</code></pre> <p>Like arrays, pointers can be used to access multiple contiguous values stored next to each other in memory.</p> <pre><code>int* p = 0; // in this example, p points to memory address 0, which corresponds to general-purpose memory.\nint first = p[0]; // get the first value stored at the address p points to\np[1] = 100; // store a new value at the address p points to plus an offset of 1 int. (which would be the address 4. 1 int = 4 bytes)\n</code></pre> <p>A pointer with the type <code>void*</code> is a special type of pointer that can point to any data type. Pointers of this type are called \"void pointers\".</p> <p>Void pointers cannot be dereferenced, they are only used as a container for arbitrary memory addresses.</p> <p>Any pointer type and be assigned the value of a void pointer, and vice versa.</p> <pre><code>int i = 100;\nfloat f = 32.2;\nvoid* p = &amp;i; // p points to i\nint x = *p; // ERROR: cannot dereference void pointers!\np = &amp;f; // p now points to f\n</code></pre> <p>Pointers can be assigned arbitrary integer values, and thus arbitrary memory addresses.</p> <p>In C, this is dangerous and discouraged most of the time, but in ERA-C it is needed to access specific parts of memory.</p> <pre><code>int* p = 0x00800000; // p now points to address 0x00800000, which is the beginning of the system's texture memory\n</code></pre> <p>Warning</p> <p>Pointers in ERA-C must be aligned when dereferencing them, meaning the address they contain must be a multiple of the size of the type they point to (or address 0). If a pointer is misaligned when it is dereferenced, en error will be raised and the program will halt.</p> <p>Pointers can be added to or subtracted from, changing the address they point to. This is referred to as \"pointer arithmetic\".</p> <p>Adding a value of 1 to a pointer will increase its address by the size of the data type it points to.</p> <p>For example, adding 1 to a <code>int*</code> will increase its address by 4, since <code>int</code>s are 4 bytes in size.</p> <p>Info</p> <p>Void pointers do not support pointer arithmetic.</p> <pre><code>int* p = 0;\np = p + 1; // p now points to the next int in memory\n</code></pre> <p>The <code>sizeof()</code> operator will return the size of a given type in bytes.</p> <pre><code>int size = sizeof(int); // size = 4\n</code></pre> <p><code>null</code> is a special constant that represents an invalid memory address. Unlike C's <code>NULL</code>, it is not equal to the integer value 0.</p> <p>Assign a pointer to <code>null</code> to signify that it does not currently point to a valid address.</p> <pre><code>void* p = null;\n</code></pre>"},{"location":"era-c-overview/#structs","title":"Structs","text":"<p>Structs are compound data types that are made up of other smaller types. They are useful for representing complex objects with many attributes.</p> <pre><code>struct MyStruct {\n  int a;\n  float b;\n  int c;\n};\n</code></pre> <p>In the above example, the struct <code>MyStruct</code> is declared, and contains an <code>int</code> and <code>float</code> members.</p> <p>Info</p> <p>Structs must be declared outside of any function, and before they are used as a variable type.</p> <p>To create a struct instance variable, use the struct name as the variable type.</p> <pre><code>MyStruct instance;\n</code></pre> <p>Struct instances can be created using the pattern <code>&lt;struct name&gt; ( &lt;member values...&gt; )</code></p> <pre><code>Mystruct instance = Mystruct(1, 2.5, 3); // create a MyStruct instance with the value (a=1, b=2.5, c=3)\n</code></pre> <p>C-style struct initializers are also allowed.</p> <p>These use the pattern <code>( &lt;struct name&gt; ) { &lt;member values...&gt; }</code></p> <pre><code>Mystruct instance = (Mystruct){1, 2.5, 3}; // create a MyStruct instance with the value (a=1, b=2.5, c=3)\n</code></pre> <p>If a struct initializer's member value list is left empty, all struct members will be initialized to zero.</p> <pre><code>MyStruct instance = MyStruct(); // instance = (0, 0.0, 0)\nvec3 v = vec3(); // v = (0.0, 0.0, 0.0)\n</code></pre> <p>To access struct members, use the dot operator. (<code>.</code>)</p> <pre><code>Mystruct instance = MyStruct(1, 2.5, 3);\nint x = instance.a; // x now contains 1\ninstance.b = 10.1; // set the b member of instance to a new value\n</code></pre> <p>When accessing a struct using a pointer, the arrow operator (<code>-&gt;</code>) must be used instead of the dot operator.</p> <pre><code>Mystruct instance = MyStruct(1, 2.5, 3);\nMyInstance* p = &amp;instance; // p points to instance\np -&gt; a = 22; // access the a member of instance using the pointer p\n</code></pre>"},{"location":"era-c-overview/#function-pointers","title":"Function Pointers","text":"<p>Function pointers are special pointers that point to code, rather than data.</p> <p>To declare a function pointer, use the pattern <code>&lt;return type&gt; ( &lt;argument types...&gt; ) &lt;variable name&gt; ;</code></p> <pre><code>void(int, float) func_ptr; // func_ptr points to a function that accepts an `int` and `float` argument and does not return a value.\n</code></pre> <p>Assign a function pointer by using the name of the function to point to.</p> <pre><code>void my_function(int a, float b) {\n  // ... function code here ...\n}\n\nvoid(int, float) func_ptr = my_function;\n</code></pre> <p>Function pointers do not support pointer arithmetic, and can only be cast to <code>void*</code>.</p> <p>Function pointers can be assigned <code>null</code>.</p>"},{"location":"era-c-overview/#type-casting","title":"Type Casting","text":"<p>Type casting in ERA-C works much like C. To cast an expression to another type, use the pattern <code>( &lt;type&gt; ) &lt;expression&gt;</code>.</p> <pre><code>float f = 2.5;\nint i = (int)f; // cast the float value of f to an int\n</code></pre> <p><code>float</code> to <code>int</code> casting discards the fractional component of the <code>float</code>. (The value is truncated)</p> <p>In the above example, <code>i</code> would have the value 2 after the cast.</p> <p>The following table lists all accepted casts:</p> Original Type Target Type Result <code>int</code> <code>float</code> <code>float</code> equal to the original integer value. <code>int</code> Non-function pointer Pointer with address equal to the original integer value. <code>float</code> <code>int</code> <code>int</code> containing the truncated integer value of the <code>float</code>. Non-function pointer <code>int</code> <code>int</code> containing the address of the original pointer value. Function pointer <code>void*</code> <code>void*</code> containing the address of the original function pointer value. <code>void*</code> Function pointer Function pointer containing the address of the original void pointer value."},{"location":"era-c-overview/#enums","title":"Enums","text":"<p>Enums are lists of compile-time constants used to represent numerical values.</p> <pre><code>// declaring an enum\nenum {\n  VALUE_A = 0, // enum entries can be assigned direct values\n  VALUE_B, // when no value is given, an entry is assigned a value that is 1 higher than the previous entry\n  VALUE_C\n};\n\n// using the enum entries\nint x = VALUE_C; // x = 2\n</code></pre> <p>Info</p> <p>Enums must be declared outside of any function, and before their members are used in an expression.</p>"},{"location":"era-c-overview/#operators","title":"Operators","text":"<p>ERA-C has the following operators:</p> Operator Description <code>+</code> Addition <code>-</code> Subtraction <code>*</code> Multiplication <code>/</code> Division <code>%</code> Modulus <code>!</code> Logical Not (Unary) <code>&amp;&amp;</code> Logical And <code>||</code> Logical Or <code>==</code> Equal-to Comparision <code>!=</code> Not-Equal-to Comparision <code>&lt;</code> Less-Than Comparision <code>&gt;</code> Greater-Than Comparision <code>&lt;=</code> Less-Than-or-Equal-to Comparision <code>&gt;=</code> Greater-Than-or-Equal-to Comparision <code>~</code> Bitwise NOT (Unary) <code>&amp;</code> Bitwise AND <code>|</code> Bitwise OR <code>^</code> Bitwise XOR <code>&lt;&lt;</code> Bitwise Left Shift <code>&gt;&gt;</code> Bitwise Logical Right Shift <code>&gt;&gt;&gt;</code> Bitwise Arithmetic Right Shift <code>.</code> Struct Member Access <code>-&gt;</code> Struct Member Access (Pointer) <code>sizeof()</code> Type Size (in bytes)"},{"location":"era-c-overview/#control-flow","title":"Control Flow","text":"<p><code>if</code> statements work just like in C.</p> <pre><code>int x = 1;\n\nif (x == 1) {\n  // do something...\n}\nelse if (x == 2) {\n  // do something else...\n}\nelse {\n  // no previous conditions were true\n}\n</code></pre> <p><code>int</code> values can be used as conditions. A value of 0 is <code>false</code>, all non-zero values are <code>true</code>.</p> <p>Pointers and function pointers can be used as the <code>if</code> statement condition to check if they point to valid addresses.</p> <pre><code>void* p = null;\n\nif (p) {\n  // p points to a valid address\n}\nelse {\n  // p is not valid\n}\n</code></pre> <p>Info</p> <p>The expression <code>my_pointer == null</code> will only be true if <code>my_pointer</code> contains exactly the value <code>null</code>.</p>"},{"location":"era-c-overview/#loops","title":"Loops","text":"<p>ERA-C supports <code>for</code> and <code>while</code> loops with the same syntax as C.</p> <p><pre><code>for (int i = 0; i &lt; 10; i = i + 1) {\n  // do something...\n}\n</code></pre> <pre><code>while (a == b) {\n  // do something...\n}\n</code></pre></p> <p>The <code>break</code> keyword will end the current loop immediately.</p> <pre><code>for (int i = 0; i &lt; 10; i = i + 1) {\n  if (i == 5) {\n    break; // exit the loop body\n  }\n\n  // do something with i...\n}\n</code></pre> <p>The <code>continue</code> keyword will skip to the next loop iteration.</p> <pre><code>for (int i = 0; i &lt; 10; i = i + 1) {\n  if (i == 5) {\n    continue; // the rest of the loop body is skipped, and the loop starts again after incrementing i\n  }\n\n  // do something with i...\n}\n</code></pre>"},{"location":"era-c-overview/#functions","title":"Functions","text":"<p>Functions in ERA-C follow mostly the same syntax as C.</p> <pre><code>// declaring a function\nvoid my_function(int a, float b) {\n   // do something...\n}\n\n// calling the function\nmy_function(1, 2.0);\n</code></pre> <p>The <code>return</code> keyword returns a value from a function.</p> <pre><code>int add(int a, int b) {\n   return a + b;\n}\n</code></pre> <p>Info</p> <p>Unlike C, a function that lists no arguments is a function that accepts no arguments.</p> <p>The C style <code>void my_function(void)</code> will not compile in ERA-C.</p>"},{"location":"era-c-overview/#vararg-functions","title":"Vararg Functions","text":"<p>Functions that accept a variable number of arguments are called \"vararg\" or \"variadic\" functions.</p> <p>The special vararg type (<code>...</code>) is used to indicate that a function is variadic.</p> <p>The vararg type must come after all other non-optional arguments.</p> <pre><code>// declaring a variadic function\nvoid my_function(int a, float b, ...) {\n  // do something...\n}\n\n// calling the function\nmy_function(1, 2.0, 3, 4, 5);\n</code></pre> <p>To access vararg arguments, use the <code>vargc()</code> and <code>vargv()</code> API functions.</p> <p><code>vargc()</code> takes no arguments and returns the remaining number of bytes available in the varargs list.</p> <pre><code>if (vargc() &gt;= 4) {\n  // there are at least 4 bytes of vararg data left.\n}\n</code></pre> <p><code>vargv()</code> returns a <code>void*</code> pointing to the current vararg argument, and accepts a size in bytes as an argument.</p> <p>The size given to <code>vargv()</code> is the offset to give the vararg pointer in order to move past the current argument.</p> <p>It is recommended to use <code>sizeof()</code> to get argument size.</p> <pre><code>int sum(...) {\n  int result = 0;\n  while (vargc() &gt;= sizeof(int)) {\n    int* arg_pointer = (int*) vargv(sizeof(int));\n    result = result + *arg_pointer;\n  }\n  return result;\n}\n\n// calling sum()\nint value = sum(1, 2, 3, 4, 5); // value = 15\n</code></pre> <p>The above snippet is an example of a simple sum function that adds a variable number of integers.</p>"},{"location":"era-c-overview/#hook-functions","title":"Hook Functions","text":"<p>ERA-3D recognizes special \"hook\" functions declared in a ERA-C program and will call them at certain times.</p> <p>At least one hook function must be declared in order for a cart to run.</p>"},{"location":"era-c-overview/#init","title":"<code>init</code>","text":"<p>if a function is declared with the signature <code>void init()</code>, it will be called once when a cart is ran.</p> <p>Use this function to initialize game state.</p> <pre><code>void init() {\n  // initialize state here...\n}\n</code></pre>"},{"location":"era-c-overview/#update","title":"<code>update</code>","text":"<p>if a function is declared with the signature <code>void update(float delta_time)</code>, it will be called once every frame.</p> <p>Use this function to update game state. (check inputs, move objects, etc.)</p> <p><code>delta_time</code> will be passed to the function automatically, and will contain the amount of time (in seconds) since the last frame.</p> <pre><code>void update(float delta_time) {\n  // update state here...\n}\n</code></pre> <p>Info</p> <p>The <code>delta_time</code> argument for <code>update()</code> can be given any other name, but it must be a <code>float</code>.</p>"},{"location":"era-c-overview/#draw","title":"<code>draw</code>","text":"<p>if a function is declared with the signature <code>void draw()</code>, it will be called once every frame after the call to <code>update()</code>.</p> <p>Use this function to configure rendering settings and to render graphics to the screen.</p> <pre><code>void draw() {\n  // render graphics here...\n}\n</code></pre>"},{"location":"era-c-overview/#built-in-constants","title":"Built-in Constants","text":"<p>The ERA-C compiler has several built-in constants for use with various functions. The following table lists their names and values:</p> Name Value <code>true</code> <code>1</code> <code>false</code> <code>0</code> <code>null</code> <code>0xFFFFFFFF</code> <code>BLEND_ALPHA</code> <code>0</code> <code>BLEND_ADD</code> <code>1</code> <code>BLEND_MULTIPLY</code> <code>2</code> <code>BLEND_ADD_ALT</code> <code>3</code> <code>BLEND_SUBTRACT</code> <code>4</code> <code>BLEND_PREMULTIPLY</code> <code>5</code> <code>BLEND_CUSTOM</code> <code>6</code> <code>BLEND_CUSTOM_EX</code> <code>7</code> <code>BTN_UP</code> <code>0</code> <code>BTN_DOWN</code> <code>1</code> <code>BTN_LEFT</code> <code>2</code> <code>BTN_RIGHT</code> <code>3</code> <code>BTN_TRIANGLE</code> <code>4</code> <code>BTN_CROSS</code> <code>5</code> <code>BTN_SQUARE</code> <code>6</code> <code>BTN_CIRCLE</code> <code>7</code> <code>BTN_L1</code> <code>8</code> <code>BTN_L2</code> <code>9</code> <code>BTN_R1</code> <code>10</code> <code>BTN_R2</code> <code>11</code> <code>BTN_SELECT</code> <code>12</code> <code>BTN_START</code> <code>13</code> <code>BTN_MOUSE_LEFT</code> <code>0</code> <code>BTN_MOUSE_RIGHT</code> <code>1</code> <code>BTN_MOUSE_MIDDLE</code> <code>2</code> <code>CAM_PERSPECTIVE</code> <code>0</code> <code>CAM_ORTHOGRAPHIC</code> <code>1</code> <code>CLEAR_NONE</code> <code>0</code> <code>CLEAR_COLOR</code> <code>0b100</code> <code>CLEAR_DEPTH</code> <code>0b010</code> <code>CLEAR_STENCIL</code> <code>0b001</code> <code>CLEAR_ALL</code> <code>0b111</code> <code>COLOR_NONE</code> <code>0</code> <code>COLOR_R</code> <code>0b1000</code> <code>COLOR_G</code> <code>0b0100</code> <code>COLOR_B</code> <code>0b0010</code> <code>COLOR_A</code> <code>0b0001</code> <code>COLOR_ALL</code> <code>0b1111</code> <code>CULL_BACK</code> <code>0</code> <code>CULL_FRONT</code> <code>1</code> <code>CULL_NONE</code> <code>2</code> <code>EQ_ADD</code> <code>0</code> <code>EQ_SUBTRACT</code> <code>1</code> <code>EQ_SUBTRACT_REVERSE</code> <code>2</code> <code>EQ_MIN</code> <code>3</code> <code>EQ_MAX</code> <code>4</code> <code>FACE_FRONT</code> <code>0</code> <code>FACE_BACK</code> <code>1</code> <code>FACE_BOTH</code> <code>2</code> <code>FACTOR_ZERO</code> <code>0</code> <code>FACTOR_ONE</code> <code>1</code> <code>FACTOR_SRC_RGB</code> <code>2</code> <code>FACTOR_ONE_MINUS_SRC_RGB</code> <code>3</code> <code>FACTOR_DST_RGB</code> <code>4</code> <code>FACTOR_ONE_MINUS_DST_RGB</code> <code>5</code> <code>FACTOR_SRC_ALPHA</code> <code>6</code> <code>FACTOR_ONE_MINUS_SRC_ALPHA</code> <code>7</code> <code>FACTOR_DST_ALPHA</code> <code>8</code> <code>FACTOR_ONE_MINUS_DST_ALPHA</code> <code>9</code> <code>FACTOR_CONSTANT_RGB</code> <code>10</code> <code>FACTOR_ONE_MINUS_CONSTANT_RGB</code> <code>11</code> <code>FACTOR_CONSTANT_ALPHA</code> <code>12</code> <code>FACTOR_ONE_MINUS_CONSTANT_ALPHA</code> <code>13</code> <code>FACTOR_SRC_ALPHA_SATURATE</code> <code>14</code> <code>FONT_WIDTH</code> <code>6</code> <code>FONT_HEIGHT</code> <code>9</code> <code>FUNC_LESS</code> <code>0</code> <code>FUNC_LEQUAL</code> <code>1</code> <code>FUNC_GREATER</code> <code>2</code> <code>FUNC_GEQUAL</code> <code>3</code> <code>FUNC_EQUAL</code> <code>4</code> <code>FUNC_NOTEQUAL</code> <code>5</code> <code>FUNC_ALWAYS</code> <code>6</code> <code>FUNC_NEVER</code> <code>7</code> <code>LIGHT_POINT</code> <code>0</code> <code>LIGHT_DIRECTIONAL</code> <code>1</code> <code>LOOP_OFF</code> <code>0</code> <code>LOOP_FORWARD</code> <code>1</code> <code>LOOP_PINGPONG</code> <code>2</code> <code>LOOP_RANGE</code> <code>3</code> <code>MAT_PROJECTION</code> <code>0</code> <code>MAT_MODELVIEW</code> <code>1</code> <code>MEMORY_HEAP</code> <code>0x00000000</code> <code>MEMORY_TEXMEM</code> <code>0x00800000</code> <code>MEMORY_OBJMEM</code> <code>0x00C00000</code> <code>MEMORY_AOBMEM</code> <code>0x00F60000</code> <code>MEMORY_SYSMEM</code> <code>0x00F62000</code> <code>MEMORY_OBJMAP</code> <code>0x00F62054</code> <code>MEMORY_WAVMAP</code> <code>0x00F63854</code> <code>MEMORY_WAVMEM</code> <code>0x01000000</code> <code>MEMORY_SEQMEM</code> <code>0x01700000</code> <code>MEMORY_TEXBANK0</code> <code>0x01800000</code> <code>MEMORY_TEXBANK1</code> <code>0x01C00000</code> <code>MEMORY_TEXBANK2</code> <code>0x02000000</code> <code>MEMORY_TEXBANK3</code> <code>0x02400000</code> <code>MEMORY_OBJBANK0</code> <code>0x02800000</code> <code>MEMORY_OBJBANK1</code> <code>0x02B60000</code> <code>MEMORY_OBJBANK2</code> <code>0x02EC0000</code> <code>MEMORY_OBJBANK3</code> <code>0x03220000</code> <code>MEMORY_OMPBANK0</code> <code>0x03580000</code> <code>MEMORY_OMPBANK1</code> <code>0x03581800</code> <code>MEMORY_OMPBANK2</code> <code>0x03583000</code> <code>MEMORY_OMPBANK3</code> <code>0x03584800</code> <code>MEMORY_WMPBANK0</code> <code>0x036C0000</code> <code>MEMORY_WMPBANK1</code> <code>0x036C2000</code> <code>MEMORY_WAVBANK0</code> <code>0x03800000</code> <code>MEMORY_WAVBANK1</code> <code>0x03F00000</code> <code>MEMORY_SEQBANK0</code> <code>0x04600000</code> <code>MEMORY_SEQBANK1</code> <code>0x04640000</code> <code>MEMORY_SEQBANK2</code> <code>0x04680000</code> <code>MEMORY_SEQBANK3</code> <code>0x046C0000</code> <code>MEMORY_SEQBANK4</code> <code>0x04700000</code> <code>MEMORY_SEQBANK5</code> <code>0x04740000</code> <code>MEMORY_SEQBANK6</code> <code>0x04780000</code> <code>MEMORY_SEQBANK7</code> <code>0x047C0000</code> <code>MEMORY_ROM</code> <code>0x04800000</code> <code>MEMORY_MEMCARD</code> <code>0x05800000</code> <code>MESH_LINES</code> <code>0</code> <code>MESH_TRIANGLES</code> <code>1</code> <code>MESH_QUADS</code> <code>2</code> <code>POLY_POINT</code> <code>0</code> <code>POLY_LINE</code> <code>1</code> <code>POLY_FILL</code> <code>2</code> <code>SCREEN_WIDTH</code> <code>480</code> <code>SCREEN_HEIGHT</code> <code>360</code> <code>STENCIL_KEEP</code> <code>0</code> <code>STENCIL_REPLACE</code> <code>1</code> <code>STENCIL_INC</code> <code>2</code> <code>STENCIL_INC_WRAP</code> <code>3</code> <code>STENCIL_DEC</code> <code>4</code> <code>STENCIL_DEC_WRAP</code> <code>5</code> <code>STENCIL_ZERO</code> <code>6</code> <code>STENCIL_INVERT</code> <code>7</code> <code>TEXTURE_WRAP</code> <code>0</code> <code>TEXTURE_CLAMP</code> <code>1</code> <code>TEXTURE_NONE</code> <code>2</code>"},{"location":"era-c-overview/#built-in-structs","title":"Built-in Structs","text":"<p>ERA-C has multiple built-in struct types for representing various objects. Unlike the vector and <code>string</code> types, which behave like structs in certain situations, these built-in structs do not have any custom functionality built into the compiler.</p>"},{"location":"era-c-overview/#matrix","title":"<code>matrix</code>","text":"<p>The <code>matrix</code> struct is a 4x4 matrix used for storing transformations like translation, rotation, and scale.</p> <p>TODO: explain member ordering</p> <pre><code>struct matrix {\n  float m0; float m4; float m8; float m12;  // first row\n  float m1; float m5; float m9; float m13;  // second row\n  float m2; float m6; float m10; float m14; // third row\n  float m3; float m7; float m11; float m15; // fourth row\n};\n</code></pre>"},{"location":"era-c-overview/#vertex","title":"<code>vertex</code>","text":"<p>The <code>vertex</code> struct contains 3D vertex data according to the order that vertex data is stored in OBJMEM and OBJBANKs.</p> <p>Thus, OBJMEM and OBJBANKs can be treated as arrays of <code>vertex</code> structs.</p> <pre><code>struct vertex {\n  vec3 position;\n  vec3 normal;\n  vec2 uv;\n  int color;\n};\n</code></pre>"},{"location":"era-c-overview/#cam2d","title":"<code>cam2d</code>","text":"<p>In SYSMEM, there are 4 memory-mapped 2D cameras that can be used for configuring the view.</p> <p>To get a pointer to a 2D camera, use the <code>getCam2D()</code> function.</p> <pre><code>cam2d* cam = getCam2D(0); // get a pointer to 2D camera 0\n</code></pre> <p>To configure the view to a built-in 2D camera, use the <code>camera2D()</code> function.</p> <pre><code>camera2D(0); // use 2D camera 0\n</code></pre> <p>Info</p> <p>When <code>camera2D()</code> is called, depth testing is automatically disabled.</p> <p>The <code>cam2d</code> struct has the following definition:</p> <pre><code>struct cam2d {\n  vec2 offset;\n  vec2 target;\n  float rotation;\n  float zoom;\n};\n</code></pre>"},{"location":"era-c-overview/#cam3d","title":"<code>cam3d</code>","text":"<p>In SYSMEM, there are 4 memory-mapped 3D cameras that can be used for configuring the view.</p> <p>To get a pointer to a 3D camera, use the <code>getCam3D()</code> function.</p> <pre><code>cam3d* cam = getCam3D(0); // get a pointer to 3D camera 0\n</code></pre> <p>To configure the view to a built-in 3D camera, use the <code>camera3D()</code> function.</p> <pre><code>camera3D(0); // use 3D camera 0\n</code></pre> <p>Info</p> <p>When <code>camera3D()</code> is called, depth testing is automatically enabled.</p> <p>The <code>cam3d</code> struct has the following definition:</p> <pre><code>struct cam3d {\n  vec3 position;\n  vec3 target;\n  vec3 up;\n  float fov;\n  int projection;\n};\n</code></pre>"},{"location":"era-c-overview/#light","title":"<code>light</code>","text":"<p>In SYSMEM, there are 8 memory-mapped lights that are used when lighting is enabled.</p> <p>To get a pointer to a light, use the <code>getLight()</code> function.</p> <pre><code>light* light0 = getLight(0); // get a pointer to light 0\n</code></pre> <p>The <code>light</code> struct has the following definition:</p> <pre><code>struct light {\n  int enabled;\n  int type;\n  float radius;\n  int color;\n  vec3 position;\n  vec3 direction;\n};\n</code></pre>"},{"location":"era-c-overview/#collision-objects","title":"Collision Objects","text":"<p>Warning</p> <p>The physics system is very experimental and subject to change.</p> <p>Currently, collision detection is only implemented for <code>colaabb</code> vs <code>colaabb</code>.</p> <p>ERA-3D has built-in API functions for 3D collision detection. These API functions accept pointers to collision object structs to know what objects to test.</p> <p>Each collision object struct contains a <code>type</code> integer member that must be set to the correct ID value in order for the collision functions to properly identify them.</p> <p>The compiler will automatically initialize the <code>type</code> member of a collision object struct to the correct ID when the struct is created, and does not need to be explicitly set by the user.</p> <pre><code>colaabb hitbox = colaabb(vec3(), 1.0, 1.0, 1.0); // the value for type is excluded and implicitly set\n</code></pre> <p>The following table lists all collision object IDs:</p> ID Collision Object Struct <code>0</code> <code>colpoint</code> <code>1</code> <code>colaabb</code> <code>2</code> <code>colsphere</code> <code>3</code> <code>colcylinder</code> <code>4</code> <code>coltriangle</code> <p>To check for collisions using these structs, use the <code>collide()</code> API function.</p> <pre><code>colaabb box1 = colaabb(vec3(), 1.0, 0.5, 1.0);\ncolaabb box2 = colaabb(vec3(), 0.5, 1.0, 0.5);\n\nif (collide(&amp;box1, &amp;box2)) {\n  // box1 and box2 are colliding!\n  // handle collision here...\n}\n</code></pre>"},{"location":"era-c-overview/#colpoint","title":"<code>colpoint</code>","text":"<p>A <code>colpoint</code> represents a single point in 3D space.</p> <pre><code>struct colpoint {\n  int type;\n  vec3 position;\n};\n</code></pre>"},{"location":"era-c-overview/#colaabb","title":"<code>colaabb</code>","text":"<p>A <code>colaabb</code> represents an Axis Aligned Bounding Box, a 3D box that cannot be rotated.</p> <pre><code>struct colaabb {\n  int type;\n  vec3 position;\n  float width;\n  float height;\n  float depth;\n};\n</code></pre>"},{"location":"era-c-overview/#colsphere","title":"<code>colsphere</code>","text":"<p>A <code>colsphere</code> represents a 3D sphere.</p> <pre><code>struct colsphere {\n  int type;\n  vec3 position;\n  float radius;\n};\n</code></pre>"},{"location":"era-c-overview/#colcylinder","title":"<code>colcylinder</code>","text":"<p>A <code>colcylinder</code> represents a 3D cylinder.</p> <pre><code>struct colcylinder {\n  int type;\n  vec3 position;\n  float height;\n  float radius;\n};\n</code></pre>"},{"location":"era-c-overview/#coltriangle","title":"<code>coltriangle</code>","text":"<p>A <code>coltriangle</code> represents a 3D triangle.</p> <pre><code>struct coltriangle {\n  int type;\n  vec3 point1;\n  vec3 point2;\n  vec3 point3;\n};\n</code></pre>"},{"location":"era-c-overview/#differences-from-c","title":"Differences From C","text":"<p>The following table lists the main differences between C and ERA-C semantics.</p> C ERA-C Multi-line comments cannot be nested Multi-line comments can be nested Multiple integer and floating-point types of various sizes Only <code>int</code> and <code>float</code>, both 32-bit (4 bytes) Leading zeros indicate octal format Leading zeros do not indicate octal format, and are ignored Pointer &lt;-&gt; Integer conversion is not generally recommended Pointer &lt;-&gt; <code>int</code> is 100% legal <code>NULL</code> <code>null</code> <code>NULL</code> == 0 <code>null</code> == <code>0xFFFFFFFF</code> <code>void foo()</code> accepts any number of arguments <code>void foo()</code> does not accept any arguments <code>void foo(void)</code> does not accept any arguments <code>void foo(void)</code> is a compile error <code>main()</code> is the program starting point Hook functions <code>init()</code>, <code>update()</code>, and <code>draw()</code> are called periodically"},{"location":"memory-map/","title":"Memory Map","text":""},{"location":"memory-map/#introduction","title":"Introduction","text":"<p>This page details ERA-3D's memory map, as of version <code>0.0.0</code>.</p> <p>Many things in ERA-3D are mapped into virtual memory, and can be modified using pointers to certain addresses.</p> <p>The following table lists all memory regions in the memory map, and each region is explained below.</p> <p>Info</p> <p>All memory in ERA-3D is arranged in big-endian format.</p>"},{"location":"memory-map/#memory-regions-table","title":"Memory Regions Table","text":"Memory Region Size Address Range Description System Memory <code>HEAP</code> <code>8MiB</code> <code>0x00000000-0x007FFFFF</code> General purpose RAM <code>TEXMEM</code> <code>4MiB</code> <code>0x00800000-0x00BFFFFF</code> Texture data <code>OBJMEM</code> <code>3MiB + 384KiB</code> <code>0x00C00000-0x00F5FFFF</code> Mesh data <code>AOBMEM</code> <code>8KiB</code> <code>0x00F60000-0x00F61FFF</code> Audio output buffer <code>SYSMEM</code> <code>632KiB</code> <code>0x00F62000-0x00FFFFFF</code> System state memory <code>WAVMEM</code> <code>7MiB</code> <code>0x01000000-0x016FFFFF</code> Audio wave data <code>SEQMEM</code> <code>256KiB</code> <code>0x01700000-0x0173FFFF</code> Audio sequencer data <code>GLOBALS</code> <code>256KiB</code> <code>0x01740000-0x0177FFFF</code> VM global variables <code>LOCALS</code> <code>256KiB</code> <code>0x01780000-0x017BFFFF</code> VM local variables <code>ARGS</code> <code>256KiB</code> <code>0x017C0000-0x017FFFFF</code> VM function arguments Cartridge ROM <code>TEXBANK[0-3]</code> <code>16MiB</code> <code>0x01800000-0x027FFFFF</code> 4 texture banks <code>OBJBANK[0-3]</code> <code>13MiB + 512KiB</code> <code>0x02800000-0x0357FFFF</code> 4 mesh data banks <code>OMPBANK[0-3]</code> <code>1MiB + 256KiB</code> <code>0x03580000-0x036BFFFF</code> 4 object maps for <code>OBJBANK[0-3]</code> <code>WMPBANK[0-1]</code> <code>1MiB + 256KiB</code> <code>0x036C0000-0x037FFFFF</code> 2 wave maps for <code>WAVBANK[0-1]</code> <code>WAVBANK[0-1]</code> <code>14MiB</code> <code>0x03800000-0x045FFFFF</code> 2 wave data banks <code>SEQBANK[0-7]</code> <code>2MiB</code> <code>0x04600000-0x047FFFFF</code> 8 audio sequencer data banks <code>ROM</code> <code>16MiB</code> <code>0x04800000-0x057FFFFF</code> String data + user ROM Memory Card <code>MEMCARD</code> <code>4KiB</code> <code>0x05800000-0x05800FFF</code> Persistent save data"},{"location":"memory-map/#system-memory","title":"System Memory","text":"<p>System memory is the region of memory that contains all data mapped to the system's internal RAM.</p> <p>Data in this memory region can be read from and written to.</p>"},{"location":"memory-map/#heap","title":"<code>HEAP</code>","text":"<p>Address range: <code>0x00000000-0x007FFFFF</code></p> <p>Accessible using constant <code>MEMORY_HEAP</code>. (Or using an address of 0.)</p> <p>The heap is an 8MiB block of general-purpose RAM that can be used in any way the user sees fit.</p> <p>The <code>alloc()</code>, <code>realloc()</code>, and <code>free()</code> API functions can be used to allocate and deallocate memory blocks in the heap for dynamic memory management.</p> <p>Alternatively, the user may choose to manage the heap manually.</p>"},{"location":"memory-map/#texmem","title":"<code>TEXMEM</code>","text":"<p>Address range: <code>0x00800000-0x00BFFFFF</code></p> <p>Accessible using constant <code>MEMORY_TEXMEM</code>.</p> <p>Contains the currently loaded texture data.</p> <p><code>TEXMEM</code> can be treated as a 1024x1024 2D array of 32-bit RGBA pixel values.</p> <p>Warning</p> <p>Updates to <code>TEXMEM</code> should only be done during <code>init()</code> and <code>update()</code>.</p> <pre><code>// get a pointer to the start of TEXMEM\nint* texture_data = MEMORY_TEXMEM;\n\n// fetch the pixel value at (x=32, y=64)\nint x = 32;\nint y = 64;\nint pixel_value = texture_data[y * 1024 + x];\n\n// set the pixel at (x=32, y=64) to white\ntexture_data[y * 1024 + x] = 0xFFFFFFFF;\n</code></pre>"},{"location":"memory-map/#objmem","title":"<code>OBJMEM</code>","text":"<p>Address range: <code>0x00C00000-0x00F5FFFF</code></p> <p>Accessible using constant <code>MEMORY_OBJMEM</code>.</p> <p>Contains the currently loaded mesh data.</p> <p>There is enough space for 32768 triangles (or 98304 vertices) to be loaded at once.</p> <p>Info</p> <p>Mesh data stored in this region should not be confused with vertices submitted directly using the <code>mesh*()</code> API functions.</p> <p>Vertices submitted using <code>mesh*()</code> functions are not accessible in the memory map.</p> <p><code>OBJMEM</code> is intended to store relatively static meshes, though it is still possible to modify <code>OBJMEM</code> meshes at runtime.</p> <p><code>OBJMEM</code> can be treated as an array of <code>vertex</code> structs.</p> <pre><code>// get a pointer to the start of OBJMEM\nvertex* obj_data = MEMORY_OBJMEM;\n\n// fetch the first loaded vertex\nvertex vert = obj_data[0];\n\n// update the first vertex in OBJMEM\nobj_data[0] = vertex(\n    vec3(1.0, 2.0, 3.0), // position\n    vec3Up(),            // normal\n    vec2(),              // uv\n    0xFF00FFFF           // color\n);\n</code></pre> <p>Meshes stored in <code>OBJMEM</code> can be drawn using the <code>drawObj()</code> and <code>drawObjEx()</code> API functions.</p> <p><code>drawObj()</code> uses the Object Map (<code>OBJMAP</code>) to draw a predefined mesh. (The <code>OBJMAP</code> is detailed in the <code>SYSMEM</code> section.)</p> <pre><code>void draw() {\n\n    // ...\n\n    pushMatrix();\n        // ... translate(), rotate(), and scale() as desired ...\n\n        // draw the mesh defined by OBJMAP entry 0\n        drawObj(0);\n    popMatrix();\n}\n</code></pre> <p><code>drawObjEx()</code> accepts parameters to control which vertices from <code>OBJMEM</code> are drawn.</p> <pre><code>void draw() {\n\n    // ...\n\n    pushMatrix();\n        // ... translate(), rotate(), and scale() as desired ...\n\n        // draw the first triangle in OBJMEM\n        drawObjEx(\n            MESH_TRIANGLES, // mesh primitive type: MESH_LINES, MESH_TRIANGLES, or MESH_QUADS\n            0, // start vertex index\n            1  // number of primitives to draw\n        );\n    popMatrix();\n}\n</code></pre>"},{"location":"memory-map/#aobmem","title":"<code>AOBMEM</code>","text":"<p>Address range: <code>0x00F60000-0x00F61FFF</code></p> <p>Accessible using constant <code>MEMORY_AOBMEM</code>.</p> <p>Contains the system audio output data.</p> <p>Audio samples stored in <code>AOBMEM</code> are 16-bit signed integer values that come in pairs for stereo audio.</p> <p>Samples are arranged such that:</p> <ul> <li>The first 16-bit value is the first sample for the left speaker</li> <li>The second value is the first sample for the right speaker</li> <li>The third value is the second sample for the left speaker</li> </ul> <p>and so on.</p> <p><code>AOBMEM</code> contains 2048 sample pairs, which are played at a sample rate of 22050hz.</p> <p>Warning</p> <p>Any changes made to audio output samples will currently be overwritten by the soundchip.</p> <p>Facilities for control over audio output are planned for the future.</p>"},{"location":"memory-map/#sysmem","title":"<code>SYSMEM</code>","text":"<p>Address range: <code>0x00F62000-0x00FFFFFF</code></p> <p>Accessible using constant <code>MEMORY_SYSMEM</code>.</p> <p>Contains state data for many aspects of the system.</p> <p><code>SYSMEM</code> is divided into multiple sub-regions, which are detailed below.</p>"},{"location":"memory-map/#soundchip-state","title":"Soundchip State","text":"<p>Address range: <code>0x00F62000-0x00F62053</code></p> <p>Contains the state of the soundchip.</p> <p>The soundchip state is layed out as follows:</p> Address(es) Size Description <code>0x00F62000</code> 1 byte Track enabled flags; the most significant bit enables track 0 <code>0x00F62001-0x00F62050</code> 80 bytes Track states; 10 bytes per track, 8 tracks <code>0x00F62051-0x00F62053</code> 3 bytes Unused <p>Track states are 10 bytes each, and have the following layout:</p> Byte Index Description 0 Playback Flags 1 BPM 2 Volume 3 Panning 4 (Reserved for future use) 5 Song Position 6 Pattern ID 7 Pattern Position 8 Groove ID 9 Groove Position"},{"location":"memory-map/#objmap","title":"<code>OBJMAP</code>","text":"<p>Address range: <code>0x00F62054-0x00F63853</code></p> <p>Accessible using constant <code>MEMORY_OBJMAP</code>.</p> <p>Contains a table of 512 user-defined mesh objects.</p> <p>Each entry in the <code>OBJMAP</code> consists of 3 32-bit <code>int</code> values, detailed in the following table:</p> <code>int</code> Index Description 0 Primitive type (must be <code>MESH_LINES</code>, <code>MESH_TRIANGLES</code>, or <code>MESH_QUADS</code>) 1 Start <code>OBJMEM</code> vertex index 2 Primitive count <p>The <code>drawObj()</code> API function accepts an index and will draw the mesh described by the corresponding entry in the <code>OBJMAP</code> table.</p> <pre><code>void init() {\n    // configure a custom OBJMAP entry\n\n    // get a pointer to the first OBJMAP entry (entry index 0)\n    int* objmap_ptr = MEMORY_OBJMAP;\n\n    // set OBJMAP entry values\n    objmap_ptr[0] = MESH_TRIANGLES; // primitive type\n    objmap_ptr[1] = 0; // start OBJMEM vertex index\n    objmap_ptr[2] = 1; // primitive count\n}\n\nvoid draw() {\n\n    // ...\n\n    pushMatrix();\n        // ... translate(), rotate(), and scale() as desired ...\n\n        // draw the mesh defined by our custom OBJMAP entry\n        drawObj(0);\n    popMatrix();\n}\n</code></pre> <p>Info</p> <p>Although <code>OBJMAP</code> entries can be created in code, they can also be automatically filled in when importing a model file using the model editor.</p>"},{"location":"memory-map/#wavmap","title":"<code>WAVMAP</code>","text":"<p>Address range: <code>0x00F63854-0x00F65853</code></p> <p>Accessible using constant <code>MEMORY_WAVMAP</code>.</p> <p>Contains a table of 512 user-defined audio wave objects.</p> <p>Each entry in the <code>WAVMAP</code> consists of 4 32-bit <code>int</code> values, detailed in the following table:</p> <code>int</code> Index Description 0 Sample start index 1 Sample end index (inclusive) 2 Loop start index 3 Loop end index (inclusive) <p>Audio sample data is stored in <code>WAVMEM</code>, and is read by the soundchip when playing sounds.</p> <p>Sample start and sample end define the range of samples to play when a sound is triggered.</p> <p>Loop start and loop end define a sample range to loop when a sound is played using the Range looping mode.</p> <p>The following diagram illustrates how this works:</p> <pre><code>no looping (normal playback):\n\n        sample start               sample end\n        v                          v\nsound: [&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;]\n\nthe whole sound is played once.\n\n---------------------------------------------\n\nrange looping:\n\n        sample start               sample end\n        v                          v\nsound: [&gt;&gt;&gt;&gt;&gt;&gt;|&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;|--------]\n              ^            ^\n              loop start   loop end\n\nthe sound is played until loop end,\nthen playback jumps back to loop start.\n</code></pre> <p><code>WAVMAP</code> entries can be used by tracker instruments to play specific sample ranges from <code>WAVMEM</code>, as well as by the user for playback using the <code>playWav()</code> API function.</p> <pre><code>void init() {\n    // configure a custom WAVMAP entry.\n    // suppose we have a sound effect loaded in WAVMEM from sample indices 0x000 to 0x1FF that we want to play,\n    // when range looping is used we want to loop from 0x100 to 0x1FF\n\n    // get a pointer to the first WAVMAP entry (entry index 0)\n    int* wavmap_ptr = MEMORY_WAVMAP;\n\n    // set WAVMAP entry values\n    wavmap_ptr[0] = 0x000; // sample start\n    wavmap_ptr[1] = 0x1FF; // sample end\n    wavmap_ptr[2] = 0x100; // loop start\n    wavmap_ptr[3] = 0x1FF; // loop end\n}\n\nvoid update(float delta_time) {\n    // play the wave defined by our custom WAVMAP entry on track 0 at 80% volume (no looping)\n    if (should_play_sound) {\n        playWav(\n            0, // track index\n            0, // WAVMAP entry index\n            0nC4, // play at note C in octave 4 (default pitch)\n            80.0, // volume\n            LOOP_OFF // loop mode\n        );\n    }\n}\n</code></pre> <p>Info</p> <p>Although <code>WAVMAP</code> entries can be created in code, they can also be automatically filled in when importing an audio file using the tracker.</p>"},{"location":"memory-map/#3d-cameras","title":"3D Cameras","text":"<p>Address range: <code>0x00F65854-0x00F65903</code></p> <p>Contains the 4 built-in 3D cameras.</p> <p>To get a pointer to a 3D camera, use the <code>getCam3D()</code> API function.</p> <pre><code>cam3d* cam = getCam3D(0); // get a pointer to 3D camera 0\n</code></pre>"},{"location":"memory-map/#2d-cameras","title":"2D Cameras","text":"<p>Address range: <code>0x00F65904-0x00F65963</code></p> <p>Contains the 4 built-in 2D cameras.</p> <p>To get a pointer to a 2D camera, use the <code>getCam2D()</code> API function.</p> <pre><code>cam2d* cam = getCam2D(0); // get a pointer to 2D camera 0\n</code></pre>"},{"location":"memory-map/#lights","title":"Lights","text":"<p>Address range: <code>0x00F65964-0x00F65AA3</code></p> <p>Contains the 8 built-in lights.</p> <p>To get a pointer to a light, use the <code>getLight()</code> API function.</p> <pre><code>light* light0 = getLight(0); // get a pointer to light 0\n</code></pre>"},{"location":"memory-map/#gpu-state","title":"GPU State","text":"<p>Address range: <code>0x00F65AA4-0x00FFFFFF</code></p> <p>TODO</p>"},{"location":"memory-map/#wavmem","title":"<code>WAVMEM</code>","text":"<p>Address range: <code>0x01000000-0x016FFFFF</code></p> <p>Accessible using constant <code>MEMORY_WAVMEM</code>.</p> <p>Contains the currently loaded audio data.</p> <p>Audio samples stored in <code>WAVMEM</code> are 16-bit signed integer values that come in pairs for stereo audio.</p> <p>Samples are arranged such that:</p> <ul> <li>The first 16-bit value is the first sample for the left speaker</li> <li>The second value is the first sample for the right speaker</li> <li>The third value is the second sample for the left speaker</li> </ul> <p>and so on.</p> <p>Audio in <code>WAVMEM</code> is played at a sample rate of 22050hz.</p> <p>There is enough space for roughly 1 minute and 23 seconds of audio data (1835008 sample pairs, to be exact) to be loaded at once.</p> <p>In other words, sample pair indices range from <code>0x000000</code> to <code>0x1BFFFF</code>.</p> <p>ERA-C does not have a built-in 16-bit integer type, but the data in <code>WAVMEM</code> can be treated as an array of <code>int</code> values.</p> <p>When used this way, each <code>int</code> in <code>WAVMEM</code> will contain a combined left + right sample pair.</p> <pre><code>// suppose we have a sound effect loaded in ROM that is 0x1FF sample pairs in length,\n// and we want to copy it into WAVMEM at a sample pair index of 0x2000.\n\nint offset = 0x2000;\n\n// pointer to the sound effect in ROM\nint* rom_ptr = address_of_sfx_in_rom;\n\n// get offset pointer to WAVMEM,\n// the cast is needed here to get the correct offset\nint* wave_data = ((int*)MEMORY_WAVMEM) + offset;\n\n// copy the sound effect into WAVMEM;\n// we multiply 0x1FF by 2 to get the number of bytes to copy\nmemcpy(wave_data, rom_ptr, 0x1FF * 2);\n</code></pre> <p>Audio stored in <code>WAVMEM</code> can be played directly using the <code>playWav()</code> and <code>playWavEx()</code> API functions.</p> <p><code>playWav()</code> uses the Wave Map (<code>WAVMAP</code>) to play a predefined wave. (The <code>WAVMAP</code> is detailed in the <code>SYSMEM</code> section.)</p> <pre><code>void update(float delta_time) {\n    // play the wave defined by WAVMAP entry 0 on track 0 at 80% volume (no looping)\n    if (should_play_sound) {\n        playWav(\n            0, // track index\n            0, // WAVMAP entry index\n            0nC4, // play at note C in octave 4 (default pitch)\n            80.0, // volume\n            LOOP_OFF // loop mode\n        );\n    }\n}\n</code></pre> <p><code>playWavEx()</code> accepts parameters to control which samples from <code>WAVMEM</code> are played, as well as a custom loop range.</p> <pre><code>void update(float delta_time) {\n    // play the first 0x1FF sample pairs in WAVMEM on track 0 at 80% volume (no looping)\n    if (should_play_sound) {\n        playWavEx(\n            0, // track index\n            0, // sample start index\n            0x1FF, // sample end index (inclusive)\n            0, // loop start index\n            0, // loop end index (inclusive)\n            0nC4, // play at note C in octave 4 (default pitch)\n            80.0, // volume\n            LOOP_OFF // loop mode\n        );\n    }\n}\n</code></pre>"},{"location":"memory-map/#seqmem","title":"<code>SEQMEM</code>","text":"<p>Address range: <code>0x01700000-0x0173FFFF</code></p> <p>Accessible using constant <code>MEMORY_SEQMEM</code>.</p> <p>Contains the currently loaded soundchip sequencer (tracker) data.</p> <p><code>SEQMEM</code> is divided into multiple sub-regions, which are detailed below.</p>"},{"location":"memory-map/#song-data","title":"Song Data","text":"<p>Address range: <code>0x01700000-0x017007FF</code></p> <p>Contains the audio sequencer song data.</p>"},{"location":"memory-map/#pattern-data","title":"Pattern Data","text":"<p>Address range: <code>0x01700800-0x17147FF</code></p> <p>Contains the audio sequencer pattern data.</p>"},{"location":"memory-map/#instrument-data","title":"Instrument Data","text":"<p>Address range: <code>0x01714800-0x017160FF</code></p> <p>Contains the audio sequencer instrument data.</p>"},{"location":"memory-map/#groove-data","title":"Groove Data","text":"<p>Address range: <code>0x01716100-0x0173FFFF</code></p> <p>Contains the audio sequencer groove data.</p>"},{"location":"memory-map/#globals","title":"<code>GLOBALS</code>","text":"<p>Address range: <code>0x01740000-0x0177FFFF</code></p> <p>Contains VM global variables.</p> <p>Getting the address of a global variable will result in a pointer to this region.</p>"},{"location":"memory-map/#locals","title":"<code>LOCALS</code>","text":"<p>Address range: <code>0x01780000-0x017BFFFF</code></p> <p>Contains VM local variables.</p> <p>Getting the address of a local variable will result in a pointer to this region.</p>"},{"location":"memory-map/#args","title":"<code>ARGS</code>","text":"<p>Address range: <code>0x017C0000-0x017FFFFF</code></p> <p>Contains VM function arguments.</p> <p>Getting the address of a function argument will result in a pointer to this region.</p>"},{"location":"memory-map/#cartridge-rom","title":"Cartridge ROM","text":"<p>Cartridge ROM is the region of memory that contains all data mapped to the currently loaded cartridge.</p> <p>Data in this memory region is read-only.</p>"},{"location":"memory-map/#texbanks","title":"<code>TEXBANK</code>s","text":"<p>Address range: <code>0x01800000-0x027FFFFF</code></p> <p>Accessible using constants <code>MEMORY_TEXBANK0</code> to <code>MEMORY_TEXBANK3</code>.</p> <p>Contains 4 texture data banks, reffered to as Texture Banks.</p> <p>Each Texture Bank has the same size and format as <code>TEXMEM</code>.</p> <p>The <code>loadTexBank()</code> API function can be used to load a Texture Bank into <code>TEXMEM</code>.</p> <pre><code>loadTexBank(0); // load TEXBANK0 into TEXMEM\n</code></pre>"},{"location":"memory-map/#objbanks","title":"<code>OBJBANK</code>s","text":"<p>Address range: <code>0x02800000-0x0357FFFF</code></p> <p>Accessible using constants <code>MEMORY_OBJBANK0</code> to <code>MEMORY_OBJBANK3</code>.</p> <p>Contains 4 mesh data banks, reffered to as Object Banks.</p> <p>Each Object Bank has the same size and format as <code>OBJMEM</code>.</p> <p>The <code>loadObjBank()</code> API function can be used to load an Object Bank into <code>OBJMEM</code>.</p> <pre><code>loadTexBank(0); // load OBJBANK0 into OBJMEM\n</code></pre> <p><code>loadObjBank()</code> will also load the associated Object Map Bank (<code>OMPBANK</code>) into the Object Map (<code>OBJMAP</code>).</p>"},{"location":"memory-map/#ompbanks","title":"<code>OMPBANK</code>s","text":"<p>Address range: <code>0x03580000-0x036BFFFF</code></p> <p>Accessible using constants <code>MEMORY_OMPBANK0</code> to <code>MEMORY_OMPBANK3</code>.</p> <p>Contains 4 Object Maps.</p> <p>Each Object Map Bank has the same size and format as <code>OBJMAP</code>, and is associated with the Object Bank with the same ID.</p>"},{"location":"memory-map/#wmpbanks","title":"<code>WMPBANK</code>s","text":"<p>Address range: <code>0x036C0000-0x037FFFFF</code></p> <p>Accessible using constants <code>MEMORY_WMPBANK0</code> and <code>MEMORY_WMPBANK1</code>.</p> <p>Contains 4 Wave Maps.</p> <p>Each Wave Map Bank has the same size and format as <code>WAVMAP</code>, and is associated with the Wave Bank with the same ID.</p>"},{"location":"memory-map/#wavbanks","title":"<code>WAVBANK</code>s","text":"<p>Address range: <code>0x03800000-0x045FFFFF</code></p> <p>Accessible using constants <code>MEMORY_WAVBANK0</code> and <code>MEMORY_WAVBANK1</code>.</p> <p>Contains 2 audio data banks, reffered to as Wave Banks.</p> <p>Each Wave Bank has the same size and format as <code>WAVMEM</code>.</p> <p>The <code>loadWavBank()</code> API function can be used to load a Wave Bank into <code>WAVMEM</code>.</p> <pre><code>loadWavBank(0); // load WAVBANK0 into WAVMEM\n</code></pre> <p><code>loadWavBank()</code> will also load the associated Wave Map Bank (<code>WMPBANK</code>) into the Wave Map (<code>WAVMAP</code>).</p>"},{"location":"memory-map/#seqbanks","title":"<code>SEQBANK</code>s","text":"<p>Address range: <code>0x04600000-0x047FFFFF</code></p> <p>Accessible using constants <code>MEMORY_SEQBANK0</code> to <code>MEMORY_SEQBANK7</code>.</p> <p>Contains 8 audio sequencer data banks, reffered to as Sequence Banks.</p> <p>Each Sequence Bank has the same size and format as <code>SEQMEM</code>.</p> <p>The <code>loadSeqBank()</code> API function can be used to load a Sequence Bank into <code>SEQMEM</code>.</p> <pre><code>loadSeqBank(0); // load SEQBANK0 into SEQMEM\n</code></pre>"},{"location":"memory-map/#rom","title":"<code>ROM</code>","text":"<p>Address range: <code>0x04800000-0x057FFFFF</code></p> <p>Accessible using constant <code>MEMORY_ROM</code>.</p> <p>Contains string literal data and user ROM data.</p> <p>Warning</p> <p>Currently, the ERA-C compiler starts at the beginning of <code>ROM</code> and writes string literal data as the cart's code is compiled.</p> <p>This will overwrite any ROM data that might be stored there.</p> <p>The compiler will also repeat string literals in ROM if identical strings are encountered.</p> <p>Facilities for reusing strings, customizing the starting address for string data, as well as uploading custom ROM data are all planned.</p>"},{"location":"memory-map/#memory-card","title":"Memory Card","text":"<p>The memory card is a region of memory that contains persistent save data.</p> <p>Data in this memory region can be read from and written to once the <code>initMemCard()</code> API function is called.</p> <p>See the API reference for <code>initMemCard()</code> for details.</p>"},{"location":"memory-map/#memcard","title":"<code>MEMCARD</code>","text":"<p>Address range: <code>0x05800000-0x05800FFF</code></p> <p>Accessible using constant <code>MEMORY_MEMCARD</code>.</p> <p>Data written here will be saved to a file that can be loaded later using the same cart ID.</p> <p>The user is free to use this memory in any way they see fit.</p>"},{"location":"user-guide/","title":"User Guide","text":""},{"location":"user-guide/#introduction","title":"Introduction","text":"<p>...</p>"},{"location":"user-guide/#general-controls","title":"General Controls","text":"<p>The following keyboard shortcuts are always available, except while an asset import dialog or the console is open:</p> <ul> <li>Ctrl+Left / Right: Switch editors</li> <li>Ctrl+R: Run cart</li> <li>Ctrl+Enter: Open/close console</li> <li>Ctrl+O: Load cart file</li> <li>Ctrl+S: Save cart</li> <li>Ctrl+Shift+S: Save cart as</li> </ul>"},{"location":"user-guide/#editor-screens","title":"Editor Screens","text":"<p>...</p>"},{"location":"user-guide/#code-editor","title":"Code Editor","text":"<p>...</p>"},{"location":"user-guide/#controls","title":"Controls","text":"<ul> <li>Left / Right / Up / Down: Move cursor</li> <li>Home: Move cursor to the beginning of the line</li> <li>End: Move cursor to the end of the line</li> <li>Page Up: Move cursor up several lines</li> <li>Page Down: Move cursor down several lines</li> <li>Alt+Up: Move line up</li> <li>Alt+Down: Move line down</li> <li>Ctrl+D: Duplicate line</li> <li>Shift+Tab: Deindent line</li> <li>Ctrl+I: Import code text file (current code is discarded!)</li> </ul>"},{"location":"user-guide/#audio-sequencer-tracker","title":"Audio Sequencer (Tracker)","text":"<p>...</p>"},{"location":"user-guide/#model-editor","title":"Model Editor","text":"<p>Warning</p> <p>The Model Editor has not been implemented yet.</p> <p>However, on the Model Editor screen, you can press Ctrl+I to import a 3D model file (<code>.obj</code>, <code>.gltf/glb</code>).</p>"},{"location":"user-guide/#texture-editor","title":"Texture Editor","text":"<p>...</p>"},{"location":"user-guide/#controls_1","title":"Controls","text":"<ul> <li>Left Click+Drag: </li> </ul>"},{"location":"user-guide/#console","title":"Console","text":"<p>...</p>"},{"location":"user-guide/#controls_2","title":"Controls","text":"<ul> <li>Up / Down: Navigate command history</li> <li>Enter: Run command</li> </ul>"}]}